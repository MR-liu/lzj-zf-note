
        <h2 id="t01. 什么是React">1. 什么是React <a href="#t01. 什么是React"> # </a></h2>
<ul>
<li>React 是一个用于构建用户界面的JavaScript库 核心专注于视图,目的实现组件化开发</li>
</ul>
<h2 id="t12.创建项目">2.创建项目 <a href="#t12.创建项目"> # </a></h2>
<pre><code class="lang-js">create-react-app zhufengreact
cd zhufengreact
yarn add cross-env
</code></pre>
<h2 id="t23.JSX渲染">3.JSX渲染 <a href="#t23.JSX渲染"> # </a></h2>
<h3 id="t33.1 什么是JSX">3.1 什么是JSX <a href="#t33.1 什么是JSX"> # </a></h3>
<ul>
<li>是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起的写法</li>
</ul>
<h3 id="t43.2 什么是元素">3.2 什么是元素 <a href="#t43.2 什么是元素"> # </a></h3>
<ul>
<li>JSX其实只是一种语法糖,最终会通过<a href="https://www.babeljs.cn/repl">babeljs</a>转译成<code>React.createElement</code>语法</li>
<li><code>React.createElement</code>会返回一个React元素</li>
<li>React元素事实上是普通的JS对象，用来描述你在屏幕上看到的内容</li>
<li><code>ReactDOM</code>来确保浏览器中的真实DOM数据和React元素保持一致</li>
</ul>
<p>JSX</p>
<pre><code class="lang-js">&lt;h1 className="title" style={{color:'red'}}&gt;hello&lt;/h1&gt;
</code></pre>
<p>转译后的代码</p>
<pre><code class="lang-js">React.createElement(<span class="hljs-string">"h1"</span>, {
  <span class="hljs-attr">className</span>: <span class="hljs-string">"title"</span>,
  <span class="hljs-attr">style</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
  }
}, <span class="hljs-string">"hello"</span>);
</code></pre>
<p>返回的结果</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">type</span>:<span class="hljs-string">'h1'</span>,
  <span class="hljs-attr">props</span>:{
    <span class="hljs-attr">className</span>: <span class="hljs-string">"title"</span>,
    <span class="hljs-attr">style</span>: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
    }
  },
  <span class="hljs-attr">children</span>:<span class="hljs-string">"hello"</span>
}
</code></pre>
<h3 id="t53.3 JSX实现">3.3 JSX实现 <a href="#t53.3 JSX实现"> # </a></h3>
<h3 id="t63.3.1 package.json">3.3.1 package.json <a href="#t63.3.1 package.json"> # </a></h3>
<pre><code class="lang-diff">{
  "name": "zhufengreact",
  "version": "0.1.0",
  "scripts": {
<span class="hljs-addition">+   "start": "cross-env DISABLE_NEW_JSX_TRANSFORM=true react-scripts start",</span>
<span class="hljs-addition">+   "build": "cross-env DISABLE_NEW_JSX_TRANSFORM=true react-scripts build",</span>
<span class="hljs-addition">+   "test": "cross-env DISABLE_NEW_JSX_TRANSFORM=true react-scripts test",</span>
<span class="hljs-addition">+   "eject": "cross-env DISABLE_NEW_JSX_TRANSFORM=true react-scripts eject"</span>
  },
}
</code></pre>
<h3 id="t73.2 src\index.js">3.2 src\index.js <a href="#t73.2 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"./react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"./react-dom"</span>;
<span class="hljs-keyword">let</span> element1 = (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> "<span class="hljs-attr">red</span>" }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>world
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(element1, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));
ReactDOM.render(element1, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));
</code></pre>
<h3 id="t83.3 constants.js">3.3 constants.js <a href="#t83.3 constants.js"> # </a></h3>
<p>src\constants.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> REACT_TEXT = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'REACT_TEXT'</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> REACT_ELEMENT = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'react.element'</span>);
</code></pre>
<h3 id="t93.4 src\utils.js">3.4 src\utils.js <a href="#t93.4 src\utils.js"> # </a></h3>
<p>src\utils.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_TEXT } <span class="hljs-keyword">from</span> <span class="hljs-string">"./constants"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapToVdom</span>(<span class="hljs-params">element</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> element === <span class="hljs-string">"string"</span> || <span class="hljs-keyword">typeof</span> element === <span class="hljs-string">"number"</span>
    ? { <span class="hljs-attr">type</span>: REACT_TEXT, <span class="hljs-attr">props</span>: { <span class="hljs-attr">content</span>: element } }
    : element;
}
</code></pre>
<h3 id="t103.5 react.js">3.5 react.js <a href="#t103.5 react.js"> # </a></h3>
<p>src\react.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { wrapToVdom } <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils"</span>;
<span class="hljs-keyword">import</span> { REACT_ELEMENT } <span class="hljs-keyword">from</span> <span class="hljs-string">"./constants"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">type, config, children</span>) </span>{
  <span class="hljs-keyword">let</span> ref;
  <span class="hljs-keyword">let</span> key;
  <span class="hljs-keyword">if</span> (config) {
    <span class="hljs-keyword">delete</span> config.__source;
    <span class="hljs-keyword">delete</span> config.__self;
    ref = config.ref;
    <span class="hljs-keyword">delete</span> config.ref;
    key = config.key;
    <span class="hljs-keyword">delete</span> config.key;
  }
  <span class="hljs-keyword">let</span> props = { ...config };
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">3</span>) {
    props.children = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>).map(wrapToVdom);
  } <span class="hljs-keyword">else</span> {
    props.children = wrapToVdom(children);
  }
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">$$typeof</span>: REACT_ELEMENT,
    type,
    ref,
    key,
    props,
  };
}
<span class="hljs-keyword">const</span> React = {
  createElement,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React;
</code></pre>
<h3 id="t113.6 react-dom.js">3.6 react-dom.js <a href="#t113.6 react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_TEXT } <span class="hljs-keyword">from</span> <span class="hljs-string">"./constants"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">vdom, container</span>) </span>{
  mount(vdom, container);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span>(<span class="hljs-params">vdom, container</span>) </span>{
  <span class="hljs-keyword">let</span> newDOM = createDOM(vdom);
  container.appendChild(newDOM);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDOM</span>(<span class="hljs-params">vdom</span>) </span>{
  <span class="hljs-keyword">let</span> { type, props } = vdom;
  <span class="hljs-keyword">let</span> dom;
  <span class="hljs-keyword">if</span> (type === REACT_TEXT) {
    dom = <span class="hljs-built_in">document</span>.createTextNode(props.content);
  } <span class="hljs-keyword">else</span> {
    dom = <span class="hljs-built_in">document</span>.createElement(type);
  }
  <span class="hljs-keyword">if</span> (props) {
    updateProps(dom, {}, props);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.children == <span class="hljs-string">"object"</span> &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  <span class="hljs-keyword">return</span> dom;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateProps</span>(<span class="hljs-params">dom, oldProps={}, newProps={}</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) {
        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'children'</span>) {
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'style'</span>) {
            <span class="hljs-keyword">let</span> styleObj = newProps[key];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attr <span class="hljs-keyword">in</span> styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        }<span class="hljs-keyword">else</span> {
            dom[key] = newProps[key];
        }
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> oldProps){
        <span class="hljs-keyword">if</span>(!newProps.hasOwnProperty(key)){
            dom[key] = <span class="hljs-literal">null</span>;
        }
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params">childrenVdom, parentDOM</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; childrenVdom.length; i++) {
    <span class="hljs-keyword">let</span> childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
<span class="hljs-keyword">const</span> ReactDOM = {
  render,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactDOM;
</code></pre>
<h2 id="t124.组件">4.组件 <a href="#t124.组件"> # </a></h2>
<ul>
<li>可以将UI切分成一些独立的、可复用的组件，这样你就只需专注于构建每一个单独的部件</li>
<li>组件从概念上类似于 <code>JavaScript</code> 函数。它接受任意的入参(props属性)，并返回用于描述页面展示内容的 React 元素</li>
</ul>
<h3 id="t134.1 函数(定义的)组件">4.1 函数(定义的)组件 <a href="#t134.1 函数(定义的)组件"> # </a></h3>
<ul>
<li>函数组件接收一个单一的props对象并返回了一个React元素</li>
<li>组件名称必须以大写字母开头</li>
<li>组件必须在使用的时候定义或引用它</li>
<li>组件的返回值只能有一个根元素</li>
<li>React元素不但可以是DOM标签，还可以是用户自定义的组件</li>
<li>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为<code>props</code></li>
</ul>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/xuan_ran_han_shu_zu_jian_1626351799850.jpg" alt="xuan_ran_han_shu_zu_jian_1626351799850"></p>
<h3 id="t144.2 实现">4.2 实现 <a href="#t144.2 实现"> # </a></h3>
<h4 id="t154.2.1 src\index.js">4.2.1 src\index.js <a href="#t154.2.1 src\index.js"> # </a></h4>
<pre><code class="lang-diff">import React from "./react";
import ReactDOM from "./react-dom";
<span class="hljs-addition">+function FunctionComponent(props){</span>
<span class="hljs-addition">+  return &lt;div className="title" style={{ color: 'red' }}&gt;&lt;span&gt;{props.name}&lt;/span&gt;{props.children}&lt;/div&gt;;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+let element = &lt;FunctionComponent name="hello"&gt;world&lt;/FunctionComponent&gt;;</span>
ReactDOM.render(element, document.getElementById("root"));
</code></pre>
<h4 id="t164.2.2 src\react-dom.js">4.2.2 src\react-dom.js <a href="#t164.2.2 src\react-dom.js"> # </a></h4>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
    }
}
export function createDOM(vdom) {
  let { type, props } = vdom;
  let dom;
  if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
<span class="hljs-addition">+ } else if (typeof type === "function") {</span>
<span class="hljs-addition">+   return mountFunctionComponent(vdom);</span>
<span class="hljs-addition">+ } else {</span>
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  return dom;
}
<span class="hljs-addition">+function mountFunctionComponent(vdom){</span>
<span class="hljs-addition">+    let {type,props}= vdom;</span>
<span class="hljs-addition">+    let renderVdom = type(props);</span>
<span class="hljs-addition">+    vdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+    return createDOM(renderVdom);</span>
<span class="hljs-addition">+}</span>
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h3 id="t174.2 类(定义的)组件">4.2 类(定义的)组件 <a href="#t174.2 类(定义的)组件"> # </a></h3>
<ul>
<li>也可以通过类定义组件</li>
<li>类组件的渲染是根据属性创建类的实例，并调用实例的render方法返回一个React元素</li>
</ul>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/lei_zu_jian_xuan_ran_1626352042061.jpg" alt="lei_zu_jian_xuan_ran_1626352042061"></p>
<h4 id="t184.2.1 src\index.js">4.2.1 src\index.js <a href="#t184.2.1 src\index.js"> # </a></h4>
<p>src\index.js</p>
<pre><code class="lang-diff">import React from "./react";
import ReactDOM from "./react-dom";
<span class="hljs-addition">+class ClassComponent extends React.Component{</span>
<span class="hljs-addition">+    render(){</span>
<span class="hljs-addition">+        return &lt;div className="title" style={{ color: 'red' }}&gt;&lt;span&gt;{this.props.name}&lt;/span&gt;{this.props.children}&lt;/div&gt;;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+let element = &lt;ClassComponent name="hello"&gt;world&lt;/ClassComponent&gt;;</span>
ReactDOM.render(element, document.getElementById("root"));
</code></pre>
<h4 id="t194.2.2 src\Component.js">4.2.2 src\Component.js <a href="#t194.2.2 src\Component.js"> # </a></h4>
<p>src\Component.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span>{
    <span class="hljs-keyword">static</span> isReactComponent=<span class="hljs-literal">true</span>
    <span class="hljs-keyword">constructor</span>(props){
        <span class="hljs-keyword">this</span>.props = props;
    }
}
</code></pre>
<h4 id="t204.2.3 src\react.js">4.2.3 src\react.js <a href="#t204.2.3 src\react.js"> # </a></h4>
<p>src\react.js</p>
<pre><code class="lang-diff">import { wrapToVdom } from "./utils";
<span class="hljs-addition">+import {Component} from './Component';</span>
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
const React = {
  createElement,
<span class="hljs-addition">+  Component</span>
};
export default React;
</code></pre>
<h4 id="t214.2.4 src\react-dom.js">4.2.4 src\react-dom.js <a href="#t214.2.4 src\react-dom.js"> # </a></h4>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
    }
}
export function createDOM(vdom) {
  let { type, props } = vdom;
  let dom;
  if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
<span class="hljs-addition">+    if (type.isReactComponent) {</span>
<span class="hljs-addition">+      return mountClassComponent(vdom);</span>
<span class="hljs-addition">+    } else {</span>
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  return dom;
}
<span class="hljs-addition">+function mountClassComponent(vdom){</span>
<span class="hljs-addition">+    let {type,props}= vdom;</span>
<span class="hljs-addition">+    let classInstance = new type(props);</span>
<span class="hljs-addition">+    let renderVdom = classInstance.render();</span>
<span class="hljs-addition">+    let dom =  createDOM(renderVdom);</span>
<span class="hljs-addition">+    return dom;</span>
<span class="hljs-addition">+}</span>
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t225.类组件的更新">5.类组件的更新 <a href="#t225.类组件的更新"> # </a></h2>
<h3 id="t235.1 组件状态">5.1 组件状态 <a href="#t235.1 组件状态"> # </a></h3>
<ul>
<li>组件的数据来源有两个地方，分别是属性对象和状态对象</li>
<li>属性是父组件传递过来的</li>
<li>状态是自己内部的,改变状态唯一的方式就是<code>setState</code></li>
<li>属性和状态的变化都会影响视图更新</li>
<li>不要直接修改 State，构造函数是唯一可以给 this.state 赋值的地方</li>
</ul>
<h3 id="t245.3 更新组新实现">5.3 更新组新实现 <a href="#t245.3 更新组新实现"> # </a></h3>
<h4 id="t255.3.1 src\index.js">5.3.1 src\index.js <a href="#t255.3.1 src\index.js"> # </a></h4>
<pre><code class="lang-diff">import React from "./react";
import ReactDOM from "./react-dom";
class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { number: 0 };
    }
    handleClick = () =&gt; {
        this.setState({ number: this.state.number + 1 });
        console.log(this.state);

    }
    render() {
        return (
            &lt;div&gt;
                &lt;p&gt;{this.props.title}&lt;/p&gt;
                &lt;p&gt;number:{this.state.number}&lt;/p&gt;
                &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}
ReactDOM.render(&lt;Counter title="计数器" /&gt;, document.getElementById("root"));
</code></pre>
<h4 id="t265.3.2 src\Component.js">5.3.2 src\Component.js <a href="#t265.3.2 src\Component.js"> # </a></h4>
<p>src\Component.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { findDOM, compareTwoVdom } from './react-dom';</span>
<span class="hljs-addition">+class Updater {</span>
<span class="hljs-addition">+    constructor(classInstance) {</span>
<span class="hljs-addition">+        this.classInstance = classInstance;</span>
<span class="hljs-addition">+        this.pendingStates = [];</span>
<span class="hljs-addition">+        this.callbacks = [];</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    addState(partialState, callback) {</span>
<span class="hljs-addition">+        this.pendingStates.push(partialState);///等待更新的或者说等待生效的状态</span>
<span class="hljs-addition">+        if (typeof callback === 'function')</span>
<span class="hljs-addition">+            this.callbacks.push(callback);//状态更新后的回调</span>
<span class="hljs-addition">+        this.emitUpdate();</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    emitUpdate() {</span>
<span class="hljs-addition">+        this.updateComponent();</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    updateComponent() {</span>
<span class="hljs-addition">+        let { classInstance, pendingStates } = this;</span>
<span class="hljs-addition">+        if (pendingStates.length &gt; 0) {</span>
<span class="hljs-addition">+            shouldUpdate(classInstance, this.getState());</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    getState() {</span>
<span class="hljs-addition">+        let { classInstance, pendingStates } = this;</span>
<span class="hljs-addition">+        let { state } = classInstance;</span>
<span class="hljs-addition">+        pendingStates.forEach((nextState) =&gt; {</span>
<span class="hljs-addition">+            if (typeof nextState === 'function') {</span>
<span class="hljs-addition">+                nextState = nextState(state);</span>
<span class="hljs-addition">+            }</span>
<span class="hljs-addition">+            state = { ...state, ...nextState };</span>
<span class="hljs-addition">+        });</span>
<span class="hljs-addition">+        pendingStates.length = 0;</span>
<span class="hljs-addition">+        return state;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function shouldUpdate(classInstance, nextState) {</span>
<span class="hljs-addition">+    classInstance.state = nextState;</span>
<span class="hljs-addition">+    classInstance.forceUpdate();</span>
<span class="hljs-addition">+}</span>
export class Component {
    static isReactComponent = true;
    constructor(props) {
        this.props = props;
<span class="hljs-addition">+        this.state = {};</span>
<span class="hljs-addition">+        this.updater = new Updater(this);</span>
    }
<span class="hljs-addition">+    setState(partialState, callback) {</span>
<span class="hljs-addition">+        this.updater.addState(partialState, callback);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    forceUpdate() {</span>
<span class="hljs-addition">+        let oldRenderVdom = this.oldRenderVdom;</span>
<span class="hljs-addition">+        let oldDOM = findDOM(oldRenderVdom);</span>
<span class="hljs-addition">+        let newRenderVdom = this.render();</span>
<span class="hljs-addition">+        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom);</span>
<span class="hljs-addition">+        this.oldRenderVdom = newRenderVdom;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h4 id="t275.3.3 react-dom.js">5.3.3 react-dom.js <a href="#t275.3.3 react-dom.js"> # </a></h4>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
    }
}
export function createDOM(vdom) {
  let { type, props } = vdom;
  let dom;
  if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  return dom;
}
function mountClassComponent(vdom) {
  let { type, props } = vdom;
  let classInstance = new type(props);
  let renderVdom = classInstance.render();
<span class="hljs-addition">+ classInstance.oldRenderVdom = renderVdom;</span>
  let dom = createDOM(renderVdom);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
<span class="hljs-addition">+export function findDOM(vdom){</span>
<span class="hljs-addition">+    let {type}= vdom;</span>
<span class="hljs-addition">+    let dom;</span>
<span class="hljs-addition">+    if(typeof type === 'function'){</span>
<span class="hljs-addition">+        dom=findDOM(vdom.oldRenderVdom);</span>
<span class="hljs-addition">+    }else{</span>
<span class="hljs-addition">+        dom=vdom.dom;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    return dom;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function compareTwoVdom(parentDOM, oldVdom, newVdom) {</span>
<span class="hljs-addition">+    let oldDOM = findDOM(oldVdom);</span>
<span class="hljs-addition">+    let newDOM = createDOM(newVdom);</span>
<span class="hljs-addition">+    parentDOM.replaceChild(newDOM, oldDOM);</span>
<span class="hljs-addition">+}</span>
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t286.合成事件和批量更新">6.合成事件和批量更新 <a href="#t286.合成事件和批量更新"> # </a></h2>
<ul>
<li>State 的更新会被合并 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state</li>
<li>State 的更新可能是异步的<ul>
<li>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用</li>
<li>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态</li>
<li>可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数</li>
</ul>
</li>
<li>事件处理<ul>
<li>React 事件的命名采用小驼峰式(camelCase),而不是纯小写</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</li>
<li>你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用<code>preventDefault</code></li>
</ul>
</li>
</ul>
<h3 id="t296.1 src\index.js">6.1 src\index.js <a href="#t296.1 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-diff">import React from "./react";
import ReactDOM from "./react-dom";
class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { number: 0 };
    }
    handleClick = () =&gt; {
<span class="hljs-addition">+       this.setState({ number: this.state.number + 1 });</span>
<span class="hljs-addition">+       console.log(this.state);</span>
<span class="hljs-addition">+       this.setState({ number: this.state.number + 1 });</span>
<span class="hljs-addition">+       console.log(this.state);</span>
<span class="hljs-addition">+       setTimeout(()=&gt;{</span>
<span class="hljs-addition">+           this.setState({ number: this.state.number + 1 });</span>
<span class="hljs-addition">+           console.log(this.state);</span>
<span class="hljs-addition">+           this.setState({ number: this.state.number + 1 });</span>
<span class="hljs-addition">+           console.log(this.state);</span>
<span class="hljs-addition">+       });</span>
    }
    render() {
        return (
            &lt;div&gt;
                &lt;p&gt;{this.props.title}&lt;/p&gt;
                &lt;p&gt;number:{this.state.number}&lt;/p&gt;
                &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}
ReactDOM.render(&lt;Counter title="计数器" /&gt;, document.getElementById("root"));
</code></pre>
<h3 id="t306.2 src\utils.js">6.2 src\utils.js <a href="#t306.2 src\utils.js"> # </a></h3>
<p>src\utils.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
export function wrapToVdom(element) {
  return typeof element <span class="hljs-comment">=== "string" || typeof element === "number"</span>
    ? { type: REACT_TEXT, props: { content: element } }
    : element;
}

<span class="hljs-addition">+export function isFunction(obj) {</span>
<span class="hljs-addition">+    return typeof obj === 'function';</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t316.3 src\Component.js">6.3 src\Component.js <a href="#t316.3 src\Component.js"> # </a></h3>
<p>src\Component.js</p>
<pre><code class="lang-diff">import { findDOM, compareTwoVdom } from './react-dom';
<span class="hljs-addition">+export let updateQueue = {</span>
<span class="hljs-addition">+    isBatchingUpdate:false,</span>
<span class="hljs-addition">+    updaters:[],</span>
<span class="hljs-addition">+    batchUpdate(){//批量更新</span>
<span class="hljs-addition">+      for(let updater of updateQueue.updaters){</span>
<span class="hljs-addition">+        updater.updateComponent();</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      updateQueue.isBatchingUpdate = false;</span>
<span class="hljs-addition">+      updateQueue.updaters.length=0;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance;
        this.pendingStates = [];
        this.callbacks = [];
    }
    addState(partialState, callback) {
        this.pendingStates.push(partialState);///等待更新的或者说等待生效的状态
        if (typeof callback <span class="hljs-comment">=== 'function')</span>
            this.callbacks.push(callback);//状态更新后的回调
        this.emitUpdate();
    }
<span class="hljs-addition">+   emitUpdate(nextProps) {</span>
<span class="hljs-addition">+       this.nextProps = nextProps;</span>
<span class="hljs-addition">+       if(updateQueue.isBatchingUpdate){</span>
<span class="hljs-addition">+           updateQueue.updaters.push(this);</span>
<span class="hljs-addition">+       }else{</span>
<span class="hljs-addition">+           this.updateComponent();</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+   }</span>
    updateComponent() {
        let { classInstance, pendingStates } = this;
<span class="hljs-addition">+       if (this.nextProps || pendingStates.length &gt; 0) {</span>
<span class="hljs-addition">+           shouldUpdate(classInstance,this.nextProps, this.getState());</span>
<span class="hljs-addition">+       }</span>
    }
    getState() {
        let { classInstance, pendingStates } = this;
        let { state } = classInstance;
        pendingStates.forEach((nextState) =&gt; {
            if (typeof nextState <span class="hljs-comment">=== 'function') {</span>
                nextState = nextState(state);
            }
            state = { ...state, ...nextState };
        });
        pendingStates.length = 0;
        return state;
    }
}
<span class="hljs-addition">+function shouldUpdate(classInstance,nextProps, nextState) {</span>
<span class="hljs-addition">+   if(nextProps) classInstance.props = nextProps;</span>
    classInstance.state = nextState;
    classInstance.forceUpdate();
}
export class Component {
    static isReactComponent = true;
    constructor(props) {
        this.props = props;
        this.state = {};
        this.updater = new Updater(this);
    }
    setState(partialState, callback) {
        this.updater.addState(partialState, callback);
    }
    forceUpdate() {
        let oldRenderVdom = this.oldRenderVdom;
        let oldDOM = findDOM(oldRenderVdom);
        let newRenderVdom = this.render();
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom);
        this.oldRenderVdom = newRenderVdom;
    }
}
</code></pre>
<h3 id="t326.4 src\event.js">6.4 src\event.js <a href="#t326.4 src\event.js"> # </a></h3>
<p>src\event.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { updateQueue } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Component'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">dom, eventType, handleClick</span>) </span>{
    <span class="hljs-keyword">let</span> store;
    <span class="hljs-keyword">if</span> (dom.store) {
        store = dom.store;
    } <span class="hljs-keyword">else</span> {
        dom.store = {};
        store = dom.store;
    }
    store[eventType] = handleClick;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">document</span>[eventType]) {
        <span class="hljs-built_in">document</span>[eventType] = dispatchEvent;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">let</span> { target, type } = event;
    <span class="hljs-keyword">let</span> eventType = <span class="hljs-string">`on<span class="hljs-subst">${type}</span>`</span>;
    updateQueue.isBatchingUpdate = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> syntheticEvent = createSyntheticEvent(event);
    <span class="hljs-keyword">while</span> (target) {
        <span class="hljs-keyword">let</span> { store } = target;
        <span class="hljs-keyword">let</span> handleClick = store &amp;&amp; store[eventType];
        handleClick &amp;&amp; handleClick.call(target, syntheticEvent);
        target = target.parentNode;
    }
    updateQueue.isBatchingUpdate = <span class="hljs-literal">false</span>;
    updateQueue.batchUpdate();
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSyntheticEvent</span>(<span class="hljs-params">nativeEvent</span>) </span>{
    <span class="hljs-keyword">let</span> syntheticEvent = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> nativeEvent) {
        syntheticEvent[key] = nativeEvent[key];
    }
    <span class="hljs-keyword">return</span> syntheticEvent;
}
</code></pre>
<h3 id="t336.5 src\react-dom.js">6.5 src\react-dom.js <a href="#t336.5 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
<span class="hljs-addition">+import { addEvent } from './event';</span>
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
    }
}
export function createDOM(vdom) {
  let { type, props } = vdom;
  let dom;
  if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  return dom;
}
function mountClassComponent(vdom) {
  let { type, props } = vdom;
  let classInstance = new type(props);
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom = renderVdom;
  let dom = createDOM(renderVdom);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
<span class="hljs-addition">+        } else if (key.startsWith('on')) {</span>
<span class="hljs-addition">+            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);</span>
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom){
    let {type}= vdom;
    let dom;
    if(typeof type <span class="hljs-comment">=== 'function'){</span>
        dom=findDOM(vdom.oldRenderVdom);
    }else{
        dom=vdom.dom;
    }
    return dom;
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom) {
    let oldDOM = findDOM(oldVdom);
    let newDOM = createDOM(newVdom);
    parentDOM.replaceChild(newDOM, oldDOM);
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t347.ref">7.ref <a href="#t347.ref"> # </a></h2>
<ul>
<li>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素</li>
</ul>
<h3 id="t357.1 为 DOM 元素添加 ref">7.1 为 DOM 元素添加 ref <a href="#t357.1 为 DOM 元素添加 ref"> # </a></h3>
<ul>
<li>可以使用 ref 去存储 DOM 节点的引用</li>
<li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性</li>
</ul>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    a
    b
    result
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.a = React.createRef();
        <span class="hljs-keyword">this</span>.b = React.createRef();
        <span class="hljs-keyword">this</span>.result = React.createRef();
    }
    handleAdd = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">this</span>.a.current.value;
        <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">this</span>.b.current.value;
        <span class="hljs-keyword">this</span>.result.current.value = a + b;
    }
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.a}</span> /&gt;</span>+<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.b}</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleAdd}</span>&gt;</span>=<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.result}</span> /&gt;</span>
            <span class="hljs-tag">&lt;/&gt;</span></span>
        );
    }
}
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Sum</span> /&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h3 id="t367.2 为 class 组件添加 Ref">7.2 为 class 组件添加 Ref <a href="#t367.2 为 class 组件添加 Ref"> # </a></h3>
<ul>
<li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性</li>
</ul>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    input
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.input = React.createRef();
    }
    getFocus = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.input.current.getFocus();
    }
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.input}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.getFocus}</span>&gt;</span>获得焦点<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/&gt;</span></span>
        );
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    input
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.input = React.createRef();
    }
    getFocus = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.input.current.focus();
    }
    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.input}</span> /&gt;</span></span>
    }
}
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Form</span> /&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h3 id="t377.3 Ref转发">7.3 Ref转发 <a href="#t377.3 Ref转发"> # </a></h3>
<ul>
<li>你不能在函数组件上使用 ref 属性，因为他们没有实例</li>
<li>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧</li>
<li>Ref 转发允许某些组件接收 ref，并将其向下传递给子组件</li>
</ul>
<p>src/index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
interface InputProps { }
<span class="hljs-keyword">const</span> TextInput = React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> /&gt;</span></span>
));
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    input
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.input = React.createRef();
    }
    getFocus = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.input.current);

        <span class="hljs-keyword">this</span>.input.current.focus();
    }
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.input}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.getFocus}</span>&gt;</span>获得焦点<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/&gt;</span></span>
        );
    }
}

ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Form</span> /&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h3 id="t387.4 ref实现">7.4 ref实现 <a href="#t387.4 ref实现"> # </a></h3>
<h4 id="t397.4.1 src\constants.js">7.4.1 src\constants.js <a href="#t397.4.1 src\constants.js"> # </a></h4>
<pre><code class="lang-diff">export const REACT_TEXT = Symbol('REACT_TEXT');
<span class="hljs-addition">+export const REACT_FORWARD_REF_TYPE = Symbol('react.forward_ref');</span>
</code></pre>
<h4 id="t407.4.2 src\react.js">7.4.2 src\react.js <a href="#t407.4.2 src\react.js"> # </a></h4>
<p>src\react.js</p>
<pre><code class="lang-diff">import { wrapToVdom } from "./utils";
import {Component} from './Component';
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
<span class="hljs-addition">+function createRef(){</span>
<span class="hljs-addition">+    return {current:null};</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function forwardRef(render) {  </span>
<span class="hljs-addition">+  var elementType = {</span>
<span class="hljs-addition">+    $$typeof: REACT_FORWARD_REF_TYPE,</span>
<span class="hljs-addition">+    render: render</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  return elementType;</span>
<span class="hljs-addition">+}</span>
const React = {
  createElement,
  Component,
<span class="hljs-addition">+ createRef</span>
};
export default React;
</code></pre>
<h4 id="t417.4.3 react-dom.js">7.4.3 react-dom.js <a href="#t417.4.3 react-dom.js"> # </a></h4>
<p>src\react-dom.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import {REACT_TEXT,REACT_FORWARD_REF_TYPE} from './constants';</span>
import { addEvent } from './event';
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
    }
}
export function createDOM(vdom) {
<span class="hljs-addition">+ let { type, props,ref } = vdom;</span>
  let dom;
<span class="hljs-addition">+ if(type&amp;&amp;type.$$typeof===REACT_FORWARD_REF_TYPE){</span>
<span class="hljs-addition">+   return mountForwardComponent(vdom);</span>
  }else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
<span class="hljs-addition">+ if(ref) ref.current = dom;</span>
  return dom;
}
<span class="hljs-addition">+function mountForwardComponent(vdom){</span>
<span class="hljs-addition">+    let {type,props,ref} = vdom;</span>
<span class="hljs-addition">+    let renderVdom = type.render(props,ref);</span>
<span class="hljs-addition">+    vdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+    return createDOM(renderVdom);</span>
<span class="hljs-addition">+}</span>
function mountClassComponent(vdom) {
<span class="hljs-addition">+ let { type, props,ref } = vdom;</span>
  let classInstance = new type(props);
<span class="hljs-addition">+ if(ref) ref.current = classInstance;</span>
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom = renderVdom;
  let dom = createDOM(renderVdom);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom){
    let {type}= vdom;
    let dom;
    if(typeof type <span class="hljs-comment">=== 'function'){</span>
        dom=findDOM(vdom.oldRenderVdom);
    }else{
        dom=vdom.dom;
    }
    return dom;
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom) {
    let oldDOM = findDOM(oldVdom);
    let newDOM = createDOM(newVdom);
    parentDOM.replaceChild(newDOM, oldDOM);
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t428.基本生命周期">8.基本生命周期 <a href="#t428.基本生命周期"> # </a></h2>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/react15_1626405471667.jpg" alt="react15_1626405471667.jpg"></p>
<h3 id="t438.1 src\index.js">8.1 src\index.js <a href="#t438.1 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ <span class="hljs-comment">// 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较</span>
    <span class="hljs-keyword">static</span> defaultProps = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'珠峰架构'</span>
    };
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> }
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 1.constructor'</span>)
    }
    componentWillMount() { <span class="hljs-comment">// 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 2.componentWillMount'</span>);
    }
    componentDidMount() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 4.componentDidMount'</span>);
    }
    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">number</span>: <span class="hljs-keyword">this</span>.state.number + <span class="hljs-number">1</span> });
    };
    <span class="hljs-comment">// react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事</span>
    shouldComponentUpdate(nextProps, nextState) { <span class="hljs-comment">// 代表的是下一次的属性 和 下一次的状态</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 5.shouldComponentUpdate'</span>);
        <span class="hljs-keyword">return</span> nextState.number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
        <span class="hljs-comment">// return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了</span>
    } <span class="hljs-comment">//不要随便用setState 可能会死循环</span>
    componentWillUpdate() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 6.componentWillUpdate'</span>);
    }
    componentDidUpdate() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 7.componentDidUpdate'</span>);
    }
    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 3.render'</span>);
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.number}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));

<span class="hljs-comment">/**
Counter 1.constructor
Counter 2.componentWillMount
Counter 3.render
Counter 4.componentDidMount
2 Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
Counter 7.componentDidUpdate
2 Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
Counter 7.componentDidUpdate
*/</span>
</code></pre>
<h3 id="t448.2 src\Component.js">8.2 src\Component.js <a href="#t448.2 src\Component.js"> # </a></h3>
<p>src\Component.js</p>
<pre><code class="lang-diff">import { findDOM, compareTwoVdom } from './react-dom';
export let updateQueue = {
    isBatchingUpdate:false,
    updaters:[],
    batchUpdate(){//批量更新
      for(let updater of updateQueue.updaters){
        updater.updateComponent();
      }
      updateQueue.isBatchingUpdate = false;
      updateQueue.updaters.length=0;
    }
}
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance;
        this.pendingStates = [];
        this.callbacks = [];
    }
    addState(partialState, callback) {
        this.pendingStates.push(partialState);///等待更新的或者说等待生效的状态
        if (typeof callback <span class="hljs-comment">=== 'function')</span>
            this.callbacks.push(callback);//状态更新后的回调
        this.emitUpdate();
    }
    emitUpdate(nextProps) {
        this.nextProps = nextProps;
        if(updateQueue.isBatchingUpdate){
            updateQueue.updaters.push(this);
        }else{
            this.updateComponent();
        }
    }
    updateComponent() {
        let { classInstance, pendingStates } = this;
        if (this.nextProps || pendingStates.length &gt; 0) {
            shouldUpdate(classInstance,this.nextProps, this.getState());
        }
    }
    getState() {
        let { classInstance, pendingStates } = this;
        let { state } = classInstance;
        pendingStates.forEach((nextState) =&gt; {
            if (typeof nextState <span class="hljs-comment">=== 'function') {</span>
                nextState = nextState(state);
            }
            state = { ...state, ...nextState };
        });
        pendingStates.length = 0;
        return state;
    }
}
function shouldUpdate(classInstance,nextProps, nextState) {
<span class="hljs-addition">+    let willUpdate = true;</span>
<span class="hljs-addition">+    if(classInstance.shouldComponentUpdate</span>
<span class="hljs-addition">+        &amp;&amp;!classInstance.shouldComponentUpdate(nextProps,nextState)){</span>
<span class="hljs-addition">+            willUpdate = false;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if(willUpdate &amp;&amp; classInstance.componentWillUpdate){</span>
<span class="hljs-addition">+        classInstance.componentWillUpdate();</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if(nextProps){</span>
<span class="hljs-addition">+        classInstance.props = nextProps;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    classInstance.state = nextState;</span>
<span class="hljs-addition">+    if(willUpdate) classInstance.forceUpdate();</span>
}
export class Component {
    static isReactComponent = true;
    constructor(props) {
        this.props = props;
        this.state = {};
        this.updater = new Updater(this);
    }
    setState(partialState, callback) {
        this.updater.addState(partialState, callback);
    }
    forceUpdate() {
        let oldRenderVdom = this.oldRenderVdom;
        let oldDOM = findDOM(oldRenderVdom);
        let newRenderVdom = this.render();
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom);
        this.oldRenderVdom = newRenderVdom;
<span class="hljs-addition">+       if(this.componentDidUpdate){</span>
<span class="hljs-addition">+           this.componentDidUpdate(this.props,this.state);</span>
<span class="hljs-addition">+       }</span>
    }
}
</code></pre>
<h3 id="t458.3 src\react-dom.js">8.3 src\react-dom.js <a href="#t458.3 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import {REACT_TEXT,REACT_FORWARD_REF_TYPE} from './constants';
import { addEvent } from './event';

function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
<span class="hljs-addition">+       if (newDOM._componentDidMount) newDOM._componentDidMount();</span>
    }
}
export function createDOM(vdom) {
  let { type, props,ref } = vdom;
  let dom;
  if(type&amp;&amp;type.$$typeof<span class="hljs-comment">===REACT_FORWARD_REF_TYPE){</span>
    return mountForwardComponent(vdom);
  }else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if(ref) ref.current = dom;
  return dom;
}
function mountForwardComponent(vdom){
    let {type,props,ref} = vdom;
    let renderVdom = type.render(props,ref);
    vdom.oldRenderVdom = renderVdom;
    return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props,ref } = vdom;
  let classInstance = new type(props);
<span class="hljs-addition">+ if(ref) ref.current = classInstance;</span>
<span class="hljs-addition">+ if (classInstance.componentWillMount) classInstance.componentWillMount();</span>
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom = renderVdom;
  let dom = createDOM(renderVdom);
<span class="hljs-addition">+ if (classInstance.componentDidMount)</span>
<span class="hljs-addition">+   dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);</span>
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom){
    let {type}= vdom;
    let dom;
    if(typeof type <span class="hljs-comment">=== 'function'){</span>
        dom=findDOM(vdom.oldRenderVdom);
    }else{
        dom=vdom.dom;
    }
    return dom;
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom) {
    let oldDOM = findDOM(oldVdom);
    let newDOM = createDOM(newVdom);
    parentDOM.replaceChild(newDOM, oldDOM);
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t469.子组件生命周期">9.子组件生命周期 <a href="#t469.子组件生命周期"> # </a></h2>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/counterdomdiff_1626412843123.jpg" alt="counterdomdiff_1626412843123"></p>
<h3 id="t479.1 src\index.js">9.1 src\index.js <a href="#t479.1 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{ <span class="hljs-comment">// 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较</span>
    <span class="hljs-keyword">static</span> defaultProps = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'珠峰架构'</span>
    };
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> }
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 1.constructor'</span>)
    }
    componentWillMount() { <span class="hljs-comment">// 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 2.componentWillMount'</span>);
    }
    componentDidMount() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 4.componentDidMount'</span>);
    }
    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">number</span>: <span class="hljs-keyword">this</span>.state.number + <span class="hljs-number">1</span> });
    };
    <span class="hljs-comment">// react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事</span>
    shouldComponentUpdate(nextProps, nextState) { <span class="hljs-comment">// 代表的是下一次的属性 和 下一次的状态</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 5.shouldComponentUpdate'</span>);
        <span class="hljs-keyword">return</span> nextState.number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
        <span class="hljs-comment">// return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了</span>
    } <span class="hljs-comment">//不要随便用setState 可能会死循环</span>
    componentWillUpdate() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 6.componentWillUpdate'</span>);
    }
    componentDidUpdate() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 7.componentDidUpdate'</span>);
    }
    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter 3.render'</span>);
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.number}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                {this.state.number === 4 ? null : <span class="hljs-tag">&lt;<span class="hljs-name">ChildCounter</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{this.state.number}</span> /&gt;</span>}
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    componentWillUnmount() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">' ChildCounter 6.componentWillUnmount'</span>)
    }
    componentWillMount() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ChildCounter 1.componentWillMount'</span>)
    }
    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ChildCounter 2.render'</span>)
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            {this.props.count}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
    }
    componentDidMount() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ChildCounter 3.componentDidMount'</span>)
    }
    componentWillReceiveProps(newProps) { <span class="hljs-comment">// 第一次不会执行，之后属性更新时才会执行</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ChildCounter 4.componentWillReceiveProps'</span>)
    }
    shouldComponentUpdate(nextProps, nextState) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ChildCounter 5.shouldComponentUpdate'</span>)
        <span class="hljs-keyword">return</span> nextProps.count % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">//子组件判断接收的属性 是否满足更新条件 为true则更新</span>
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));


<span class="hljs-comment">/**
click 1
Counter 1.constructor
Counter 2.componentWillMount
Counter 3.render
ChildCounter 1.componentWillMount
ChildCounter 2.render
ChildCounter 3.componentDidMount
Counter 4.componentDidMount

click 2 
Counter 5.shouldComponentUpdate
click 3
Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
ChildCounter 4.componentWillReceiveProps
Counter 5.shouldComponentUpdate
Counter 7.componentDidUpdate

click3
Counter 5.shouldComponentUpdate

click4
Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
ChildCounter 6.componentWillUnmount
Counter 7.componentDidUpdate

click5
Counter 5.shouldComponentUpdate

click6
Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
ChildCounter 1.componentWillMount
ChildCounter 2.render
ChildCounter 3.componentDidMount
Counter 7.componentDidUpdate

click7
Counter 5.shouldComponentUpdate

click8
Counter 5.shouldComponentUpdate
Counter 6.componentWillUpdate
Counter 3.render
ChildCounter 4.componentWillReceiveProps
Counter 5.shouldComponentUpdate
Counter 7.componentDidUpdate
 */</span>
</code></pre>
<h3 id="t489.2 src\react-dom.js">9.2 src\react-dom.js <a href="#t489.2 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { REACT_TEXT, REACT_FORWARD_REF_TYPE } from "./constants";</span>
<span class="hljs-addition">+import { addEvent } from "./event";</span>

function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
        if (newDOM._componentDidMount) newDOM._componentDidMount();
    }
}
export function createDOM(vdom) {
 let { type, props, ref } = vdom;
  let dom;
  if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_FORWARD_REF_TYPE) {</span>
    return mountForwardComponent(vdom);
  } else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if (ref) ref.current = dom;
  return dom;
}
function mountForwardComponent(vdom) {
  let { type, props, ref } = vdom;
  let renderVdom = type.render(props, ref);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props, ref } = vdom;
  let classInstance = new type(props);
<span class="hljs-addition">+ vdom.classInstance = classInstance;</span>
  if (ref) ref.current = classInstance;
  if (classInstance.componentWillMount) classInstance.componentWillMount();
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom =  renderVdom;
  let dom = createDOM(renderVdom);
  if (classInstance.componentDidMount)
    dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom) {
    if (!vdom) return null;
    if (vdom.dom) {//vdom={type:'h1'}
        return vdom.dom;
    } else {
        let renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom;
        return findDOM(renderVdom);
    }
}
<span class="hljs-addition">+function unMountVdom(vdom) {</span>
<span class="hljs-addition">+    let { type, props, ref } = vdom;</span>
<span class="hljs-addition">+    let currentDOM = findDOM(vdom);//获取此虚拟DOM对应的真实DOM</span>
<span class="hljs-addition">+    //vdom可能是原生组件span 类组件 classComponent 也可能是函数组件Function</span>
<span class="hljs-addition">+    if (vdom.classInstance &amp;&amp; vdom.classInstance.componentWillUnmount) {</span>
<span class="hljs-addition">+        vdom.classInstance.componentWillUnmount();</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (ref) {</span>
<span class="hljs-addition">+        ref.current = null;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    //如果此虚拟DOM有子节点的话，递归全部删除</span>
<span class="hljs-addition">+    if (props.children) {</span>
<span class="hljs-addition">+        //得到儿子的数组</span>
<span class="hljs-addition">+        let children = Array.isArray(props.children) ? props.children : [props.children];</span>
<span class="hljs-addition">+        children.forEach(unMountVdom);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    //把自己这个虚拟DOM对应的真实DOM从界面删除</span>
<span class="hljs-addition">+    if (currentDOM) currentDOM.parentNode.removeChild(currentDOM);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function compareTwoVdom(parentDOM, oldVdom, newVdom,nextDOM) {</span>
<span class="hljs-addition">+  if (!oldVdom &amp;&amp; !newVdom) {</span>
<span class="hljs-addition">+    //老和新都是没有</span>
<span class="hljs-addition">+    return;</span>
<span class="hljs-addition">+  } else if (!!oldVdom &amp;&amp; !newVdom) {</span>
<span class="hljs-addition">+    //老有新没有</span>
<span class="hljs-addition">+    unMountVdom(oldVdom);</span>
<span class="hljs-addition">+  } else if (!oldVdom &amp;&amp; !!newVdom) {</span>
<span class="hljs-addition">+    //老没有新的有</span>
<span class="hljs-addition">+    let newDOM = createDOM(newVdom);</span>
<span class="hljs-addition">+    if (nextDOM) parentDOM.insertBefore(newDOM, nextDOM);</span>
<span class="hljs-addition">+    else parentDOM.appendChild(newDOM);</span>
<span class="hljs-addition">+    if (newDOM.componentDidMount) newDOM.componentDidMount();</span>
<span class="hljs-addition">+    return;</span>
<span class="hljs-addition">+  } else if (!!oldVdom &amp;&amp; !!newVdom &amp;&amp; oldVdom.type !== newVdom.type) {</span>
<span class="hljs-addition">+    //新老都有，但类型不同</span>
<span class="hljs-addition">+    let newDOM = createDOM(newVdom);</span>
<span class="hljs-addition">+    unMountVdom(oldVdom);</span>
<span class="hljs-addition">+    if (newDOM.componentDidMount) newDOM.componentDidMount();</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    updateElement(oldVdom, newVdom);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateElement(oldVdom, newVdom) {</span>
<span class="hljs-addition">+    if (oldVdom.type === REACT_TEXT &amp;&amp; newVdom.type === REACT_TEXT) {</span>
<span class="hljs-addition">+       let currentDOM = newVdom.dom = findDOM(oldVdom);</span>
<span class="hljs-addition">+       if (oldVdom.props.content !== newVdom.props.content) {</span>
<span class="hljs-addition">+           currentDOM.textContent = newVdom.props.content;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       return;</span>
<span class="hljs-addition">+    }else if (typeof oldVdom.type === 'string') {</span>
<span class="hljs-addition">+        let currentDOM = newVdom.dom = findDOM(oldVdom);</span>
<span class="hljs-addition">+        updateProps(currentDOM, oldVdom.props, newVdom.props);</span>
<span class="hljs-addition">+        updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);</span>
<span class="hljs-addition">+    } else if (typeof oldVdom.type === 'function') {</span>
<span class="hljs-addition">+        if (oldVdom.type.isReactComponent) {</span>
<span class="hljs-addition">+            newVdom.classInstance = oldVdom.classInstance;</span>
<span class="hljs-addition">+            updateClassComponent(oldVdom, newVdom);</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+            updateFunctionComponent(oldVdom, newVdom);</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateFunctionComponent(oldVdom, newVdom) {</span>
<span class="hljs-addition">+    let parentDOM = findDOM(oldVdom).parentNode;</span>
<span class="hljs-addition">+    let { type, props } = newVdom;</span>
<span class="hljs-addition">+    let newRenderVdom = type(props);</span>
<span class="hljs-addition">+    compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom);</span>
<span class="hljs-addition">+    newVdom.oldRenderVdom = newRenderVdom;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateClassComponent(oldVdom, newVdom) {</span>
<span class="hljs-addition">+    let classInstance = newVdom.classInstance = oldVdom.classInstance;</span>
<span class="hljs-addition">+    if (classInstance.componentWillReceiveProps) {</span>
<span class="hljs-addition">+        classInstance.componentWillReceiveProps(newVdom.props);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    classInstance.updater.emitUpdate(newVdom.props);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateChildren(parentDOM, oldVChildren, newVChildren) {</span>
<span class="hljs-addition">+    oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : oldVChildren ? [oldVChildren] : [];</span>
<span class="hljs-addition">+    newVChildren = Array.isArray(newVChildren) ? newVChildren : newVChildren ? [newVChildren] : [];</span>
<span class="hljs-addition">+    let maxLength = Math.max(oldVChildren.length, newVChildren.length);</span>
<span class="hljs-addition">+    for (let i = 0; i &lt; maxLength; i++) {</span>
<span class="hljs-addition">+       let nextVdom = oldVChildren.find((item,index)=&gt;index&gt;i&amp;&amp;item&amp;&amp;findDOM(item));</span>
<span class="hljs-addition">+       compareTwoVdom(parentDOM, oldVChildren[i], newVChildren[i],nextVdom&amp;&amp;findDOM(nextVdom));</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+}</span>
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t4910.DOM-DIFF算法">10.DOM-DIFF算法 <a href="#t4910.DOM-DIFF算法"> # </a></h2>
<ul>
<li>只对同级节点进行对比，如果DOM节点跨层级移动，则React不会复用</li>
<li>不同类型的元素会产出不同的结构 ，会销毁老结构，创建新结构</li>
<li>可以通过<code>key</code>标识移动的元素</li>
</ul>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/domdiff_1626417725773.jpg" alt="domdiff_1626417725773"></p>
<h3 id="t5010.1 src\index.js">10.1 src\index.js <a href="#t5010.1 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">list</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>]
        }
    }
    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">list</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'G'</span>]
        });
    };
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                    {
                        this.state.list.map(item =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item}</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)
                    }

                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
        )
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t5110.2 src\constants.js">10.2 src\constants.js <a href="#t5110.2 src\constants.js"> # </a></h3>
<p>src\constants.js</p>
<pre><code class="lang-diff">export const REACT_TEXT = Symbol('REACT_TEXT');
export const REACT_FORWARD_REF_TYPE = Symbol('react.forward_ref');
<span class="hljs-addition">+export const REACT_FRAGMENT = Symbol('react.fragment')</span>
<span class="hljs-addition">+export const PLACEMENT = 'PLACEMENT';</span>
<span class="hljs-addition">+export const MOVE = 'MOVE';</span>
</code></pre>
<h3 id="t5210.3 src\react.js">10.3 src\react.js <a href="#t5210.3 src\react.js"> # </a></h3>
<p>src\react.js</p>
<pre><code class="lang-diff">import { wrapToVdom } from "./utils";
import { Component } from './Component';
<span class="hljs-addition">+import { REACT_FORWARD_REF_TYPE,REACT_FRAGMENT } from './constants';</span>
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
function createRef() {
  return { current: null };
}
function forwardRef(render) {
  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
  return elementType;
}
const React = {
  createElement,
  Component,
  createRef,
  forwardRef,
  Fragment: REACT_FRAGMENT
};
export default React;
</code></pre>
<h3 id="t5310.4 src\react-dom.js">10.4 src\react-dom.js <a href="#t5310.4 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { REACT_TEXT, REACT_FORWARD_REF_TYPE, PLACEMENT, MOVE ,REACT_FRAGMENT} from "./constants";</span>
import { addEvent } from "./event";
<span class="hljs-addition">+import React from './react';</span>
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
        if (newDOM._componentDidMount) newDOM._componentDidMount();
    }
}
export function createDOM(vdom) {
  let { type, props, ref } = vdom;
  let dom;
  if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_FORWARD_REF_TYPE) {</span>
    return mountForwardComponent(vdom);
  } else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
<span class="hljs-addition">+ } else if (oldVdom.type === REACT_FRAGMENT) {</span>
<span class="hljs-addition">+  dom=document.createDocumentFragment();</span>
<span class="hljs-addition">+ }else if (typeof type === "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
     return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
<span class="hljs-addition">+     props.children.mountIndex = 0;</span>
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if (ref) ref.current = dom;
  return dom;
}

function mountForwardComponent(vdom) {
  let { type, props, ref } = vdom;
  let renderVdom = type.render(props, ref);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props, ref } = vdom;
  let classInstance = new type(props);
  vdom.classInstance = classInstance;
  if (ref) ref.current = classInstance;
  if (classInstance.componentWillMount) classInstance.componentWillMount();
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom  = renderVdom;
  let dom = createDOM(renderVdom);
  if (classInstance.componentDidMount)
    dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom) {
    if (!vdom) return null;
    if (vdom.dom) {//vdom={type:'h1'}
        return vdom.dom;
    } else {
        let renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom;
        return findDOM(renderVdom);
    }
}
function unMountVdom(vdom) {
    let { type, props, ref } = vdom;
    let currentDOM = findDOM(vdom);//获取此虚拟DOM对应的真实DOM
    //vdom可能是原生组件span 类组件 classComponent 也可能是函数组件Function
    if (vdom.classInstance &amp;&amp; vdom.classInstance.componentWillUnmount) {
        vdom.classInstance.componentWillUnmount();
    }
    if (ref) {
        ref.current = null;
    }
    //如果此虚拟DOM有子节点的话，递归全部删除
    if (props.children) {
        //得到儿子的数组
        let children = Array.isArray(props.children) ? props.children : [props.children];
        children.forEach(unMountVdom);
    }
    //把自己这个虚拟DOM对应的真实DOM从界面删除
    if (currentDOM) currentDOM.parentNode.removeChild(currentDOM);
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom, nextDOM) {
  if (!oldVdom &amp;&amp; !newVdom) {
    //老和新都是没有
    return;
  } else if (!!oldVdom &amp;&amp; !newVdom) {
    //老有新没有
    unMountVdom(oldVdom);
  } else if (!oldVdom &amp;&amp; !!newVdom) {
    //老没有新的有
    let newDOM = createDOM(newVdom);
    if (nextDOM) parentDOM.insertBefore(newDOM, nextDOM);
    else parentDOM.appendChild(newDOM);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
    return;
  } else if (!!oldVdom &amp;&amp; !!newVdom &amp;&amp; oldVdom.type !== newVdom.type) {
    //新老都有，但类型不同
    let newDOM = createDOM(newVdom);
    unMountVdom(oldVdom);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
  } else {
    updateElement(oldVdom, newVdom);
  }
}
function updateElement(oldVdom, newVdom) {
  if (oldVdom.type <span class="hljs-comment">=== REACT_TEXT &amp;&amp; newVdom.type === REACT_TEXT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    if (oldVdom.props.content !== newVdom.props.content) {
      currentDOM.textContent = newVdom.props.content;
    }
    return;
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'string') {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateProps(currentDOM, oldVdom.props, newVdom.props);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
<span class="hljs-addition">+ } else if (oldVdom.type === REACT_FRAGMENT) {</span>
<span class="hljs-addition">+   dom = document.createDocumentFragment();</span>
<span class="hljs-addition">+ } else if (typeof oldVdom.type === 'function') {</span>
    if (oldVdom.type.isReactComponent) {
      newVdom.classInstance = oldVdom.classInstance;
      updateClassComponent(oldVdom, newVdom);
    } else {
     updateFunctionComponent(oldVdom, newVdom);
    }
  }
}
function updateFunctionComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let newRenderVdom = type(props);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom);
  newVdom.oldRenderVdom = newRenderVdom;
}
function updateClassComponent(oldVdom, newVdom) {
  let classInstance = newVdom.classInstance = oldVdom.classInstance;
  if (classInstance.componentWillReceiveProps) {
    classInstance.componentWillReceiveProps();
  }
  classInstance.updater.emitUpdate(newVdom.props);
}
function updateChildren(parentDOM, oldVChildren, newVChildren) {
<span class="hljs-addition">+  oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : oldVChildren ? [oldVChildren] : [];</span>
<span class="hljs-addition">+  newVChildren = Array.isArray(newVChildren) ? newVChildren : newVChildren ? [newVChildren] : [];</span>
<span class="hljs-addition">+  let keyedOldMap = {};</span>
<span class="hljs-addition">+  let lastPlacedIndex = 0;</span>
<span class="hljs-addition">+  oldVChildren.forEach((oldVChild, index) =&gt; {</span>
<span class="hljs-addition">+    let oldKey = oldVChild.key ? oldVChild.key : index;</span>
<span class="hljs-addition">+    keyedOldMap[oldKey] = oldVChild;</span>
<span class="hljs-addition">+  });</span>
<span class="hljs-addition">+  let patch = [];</span>
<span class="hljs-addition">+  newVChildren.forEach((newVChild, index) =&gt; {</span>
<span class="hljs-addition">+    newVChild.mountIndex = index;</span>
<span class="hljs-addition">+    let newKey = newVChild.key ? newVChild.key : index;</span>
<span class="hljs-addition">+    let oldVChild = keyedOldMap[newKey];</span>
<span class="hljs-addition">+    if (oldVChild) {</span>
<span class="hljs-addition">+      updateElement(oldVChild, newVChild);</span>
<span class="hljs-addition">+      if (oldVChild.mountIndex &lt; lastPlacedIndex) {</span>
<span class="hljs-addition">+        patch.push({</span>
<span class="hljs-addition">+          type: MOVE,</span>
<span class="hljs-addition">+          oldVChild,</span>
<span class="hljs-addition">+          newVChild,</span>
<span class="hljs-addition">+          mountIndex: index</span>
<span class="hljs-addition">+        });</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      delete keyedOldMap[newKey];</span>
<span class="hljs-addition">+      lastPlacedIndex = Math.max(lastPlacedIndex, oldVChild.mountIndex);</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      patch.push({</span>
<span class="hljs-addition">+        type: PLACEMENT,</span>
<span class="hljs-addition">+        newVChild,</span>
<span class="hljs-addition">+        mountIndex: index</span>
<span class="hljs-addition">+      });</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  });</span>
<span class="hljs-addition">+  let moveVChild = patch.filter(action =&gt; action.type === MOVE).map(action =&gt; action.oldVChild);</span>
<span class="hljs-addition">+  Object.values(keyedOldMap).concat(moveVChild).forEach((oldVChild) =&gt; {</span>
<span class="hljs-addition">+    let currentDOM = findDOM(oldVChild);</span>
<span class="hljs-addition">+    parentDOM.removeChild(currentDOM);</span>
<span class="hljs-addition">+  });</span>
<span class="hljs-addition">+  patch.forEach(action =&gt; {</span>
<span class="hljs-addition">+    let { type, oldVChild, newVChild, mountIndex } = action;</span>
<span class="hljs-addition">+    let childNodes = parentDOM.childNodes;</span>
<span class="hljs-addition">+    if (type === PLACEMENT) {</span>
<span class="hljs-addition">+      let newDOM = createDOM(newVChild);</span>
<span class="hljs-addition">+      let childNode = childNodes[mountIndex];</span>
<span class="hljs-addition">+      if (childNode) {</span>
<span class="hljs-addition">+        parentDOM.insertBefore(newDOM, childNode);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        parentDOM.appendChild(newDOM);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else if (type === MOVE) {</span>
<span class="hljs-addition">+      let oldDOM = findDOM(oldVChild);</span>
<span class="hljs-addition">+      let childNode = childNodes[mountIndex];</span>
<span class="hljs-addition">+      if (childNode) {</span>
<span class="hljs-addition">+        parentDOM.insertBefore(oldDOM, childNode);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        parentDOM.appendChild(oldDOM);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  });</span>
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
<span class="hljs-addition">+   childVdom.mountIndex = i;</span>
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;
</code></pre>
<h2 id="t5411.新的生命周期">11.新的生命周期 <a href="#t5411.新的生命周期"> # </a></h2>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/react16_1626532331619.jpg" alt="react16_1626532331619"></p>
<h3 id="t5511.1 getDerivedStateFromProps">11.1 getDerivedStateFromProps <a href="#t5511.1 getDerivedStateFromProps"> # </a></h3>
<ul>
<li><code>static getDerivedStateFromProps(props, state)</code> 这个生命周期的功能实际上就是将传入的props映射到state上面</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-keyword">static</span> defaultProps = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'珠峰架构'</span>
    };
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> }
    }

    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">number</span>: <span class="hljs-keyword">this</span>.state.number + <span class="hljs-number">1</span> });
    };

    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'3.render'</span>);
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.number}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ChildCounter</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{this.state.number}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> };
    }
    <span class="hljs-keyword">static</span> getDerivedStateFromProps(nextProps, prevState) {
        <span class="hljs-keyword">const</span> { number } = nextProps;
        <span class="hljs-comment">// 当传入的type发生变化的时候，更新state</span>
        <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">number</span>: number * <span class="hljs-number">2</span> };
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">number</span>: number * <span class="hljs-number">3</span> };
        }
    }
    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child-render'</span>, <span class="hljs-keyword">this</span>.state)
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            {this.state.number}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
    }

}

ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h3 id="t5611.2 getSnapshotBeforeUpdate">11.2 getSnapshotBeforeUpdate <a href="#t5611.2 getSnapshotBeforeUpdate"> # </a></h3>
<ul>
<li>getSnapshotBeforeUpdate() 被调用于render之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">messages</span>: [] }
        <span class="hljs-keyword">this</span>.wrapper = React.createRef();
    }

    addMessage() {
        <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
            <span class="hljs-attr">messages</span>: [<span class="hljs-string">`<span class="hljs-subst">${state.messages.length}</span>`</span>, ...state.messages],
        }))
    }
    componentDidMount() {
        <span class="hljs-keyword">this</span>.timeID = <span class="hljs-built_in">window</span>.setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-comment">//设置定时器</span>
            <span class="hljs-keyword">this</span>.addMessage();
        }, <span class="hljs-number">1000</span>)
    }
    componentWillUnmount() {<span class="hljs-comment">//清除定时器</span>
        <span class="hljs-built_in">window</span>.clearInterval(<span class="hljs-keyword">this</span>.timeID);
    }
    getSnapshotBeforeUpdate() {<span class="hljs-comment">//很关键的，我们获取当前rootNode的scrollHeight，传到componentDidUpdate 的参数perScrollHeight</span>
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">prevScrollTop</span>:<span class="hljs-keyword">this</span>.wrapper.current.scrollTop,<span class="hljs-attr">prevScrollHeight</span>:<span class="hljs-keyword">this</span>.wrapper.current.scrollHeight};
    }
    componentDidUpdate(pervProps, pervState, {prevScrollHeight,prevScrollTop}) {
        <span class="hljs-comment">//当前向上卷去的高度加上增加的内容高度</span>
        <span class="hljs-keyword">this</span>.wrapper.current.scrollTop = prevScrollTop + (<span class="hljs-keyword">this</span>.wrapper.current.scrollHeight - prevScrollHeight);
    }
    render() {
        <span class="hljs-keyword">let</span> style = {
            <span class="hljs-attr">height</span>: <span class="hljs-string">'100px'</span>,
            <span class="hljs-attr">width</span>: <span class="hljs-string">'200px'</span>,
            <span class="hljs-attr">border</span>: <span class="hljs-string">'1px solid red'</span>,
            <span class="hljs-attr">overflow</span>: <span class="hljs-string">'auto'</span>
        }
        <span class="hljs-comment">//&lt;div key={index}&gt;里不要加空格!</span>
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.wrapper}</span> &gt;</span>
                {this.state.messages.map((message, index) =&gt; (
                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                ))}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
}

ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ScrollingList</span> /&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<h3 id="t5711.3 实现">11.3 实现 <a href="#t5711.3 实现"> # </a></h3>
<h4 id="t5811.3.1  src\Component.js">11.3.1  src\Component.js <a href="#t5811.3.1  src\Component.js"> # </a></h4>
<pre><code class="lang-diff">import { findDOM, compareTwoVdom } from './react-dom';
export let updateQueue = {
    isBatchingUpdate: false,
    updaters: [],
    batchUpdate() {//批量更新
        for (let updater of updateQueue.updaters) {
            updater.updateComponent();
        }
        updateQueue.isBatchingUpdate = false;
        updateQueue.updaters.length = 0;
    }
}
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance;
        this.pendingStates = [];
        this.callbacks = [];
    }
    addState(partialState, callback) {
        this.pendingStates.push(partialState);///等待更新的或者说等待生效的状态
        if (typeof callback <span class="hljs-comment">=== 'function')</span>
            this.callbacks.push(callback);//状态更新后的回调
        this.emitUpdate();
    }
    emitUpdate(nextProps) {
        this.nextProps = nextProps;
        if (updateQueue.isBatchingUpdate) {
            updateQueue.updaters.push(this);
        } else {
            this.updateComponent();
        }
    }
    updateComponent() {
        let { classInstance, pendingStates } = this;
        if (this.nextProps || pendingStates.length &gt; 0) {
            shouldUpdate(classInstance, this.nextProps, this.getState());
        }
    }
    getState() {
        let { classInstance, pendingStates } = this;
        let { state } = classInstance;
        pendingStates.forEach((nextState) =&gt; {
            if (typeof nextState <span class="hljs-comment">=== 'function') {</span>
                nextState = nextState(state);
            }
            state = { ...state, ...nextState };
        });
        pendingStates.length = 0;
        return state;
    }
}
function shouldUpdate(classInstance, nextProps, nextState) {
    let willUpdate = true;
    if (classInstance.shouldComponentUpdate
        &amp;&amp; !classInstance.shouldComponentUpdate(nextProps, nextState)) {
        willUpdate = false;
    }
    if (willUpdate &amp;&amp; classInstance.componentWillUpdate) {
        classInstance.componentWillUpdate();
    }
    if (nextProps) {
        classInstance.props = nextProps;
    }
    classInstance.state = nextState;
    if (willUpdate) classInstance.forceUpdate();
}
export class Component {
    static isReactComponent = true;
    constructor(props) {
        this.props = props;
        this.state = {};
        this.updater = new Updater(this);
    }
    setState(partialState, callback) {
        this.updater.addState(partialState, callback);
    }
    forceUpdate() {
        let oldRenderVdom = this.oldRenderVdom;
        let oldDOM = findDOM(oldRenderVdom);
<span class="hljs-addition">+        if (this.constructor.getDerivedStateFromProps) {</span>
<span class="hljs-addition">+            let newState = this.constructor.getDerivedStateFromProps(this.props, this.state);</span>
<span class="hljs-addition">+            if (newState)</span>
<span class="hljs-addition">+                this.state = newState;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+       let snapshot = this.getSnapshotBeforeUpdate &amp;&amp; this.getSnapshotBeforeUpdate();</span>
        let newRenderVdom = this.render();
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom);
        this.oldRenderVdom = newRenderVdom;
        if (this.componentDidUpdate) {
<span class="hljs-addition">+            this.componentDidUpdate(this.props, this.state, snapshot);</span>
        }
    }
}
</code></pre>
<h2 id="t5912. Context(上下文)">12. Context(上下文) <a href="#t5912. Context(上下文)"> # </a></h2>
<ul>
<li>在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用强大的contextAPI解决上述问题</li>
<li>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props</li>
</ul>
<p><img src="https://upload-markdown-images.oss-cn-beijing.aliyuncs.com/contextapi_1626532435193.gif" alt="contextapi_1626532435193"></p>
<h3 id="t6012.1 src\index.js">12.1 src\index.js <a href="#t6012.1 src\index.js"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-keyword">let</span> ThemeContext = React.createContext(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">let</span> root = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#root'</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
                {
                    (value) =&gt; (
                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">border:</span> `<span class="hljs-attr">5px</span> <span class="hljs-attr">solid</span> ${<span class="hljs-attr">value.color</span>}`, <span class="hljs-attr">padding:</span> '<span class="hljs-attr">5px</span>' }}&gt;</span>
                            header
                            <span class="hljs-tag">&lt;<span class="hljs-name">Title</span> /&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                    )
                }
            <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span>
        )
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
                {
                    (value) =&gt; (
                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">border:</span> `<span class="hljs-attr">5px</span> <span class="hljs-attr">solid</span> ${<span class="hljs-attr">value.color</span>}` }}&gt;</span>
                            title
                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                    )
                }
            <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span>
        )
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
                {
                    (value) =&gt; (
                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">border:</span> `<span class="hljs-attr">5px</span> <span class="hljs-attr">solid</span> ${<span class="hljs-attr">value.color</span>}`, <span class="hljs-attr">margin:</span> '<span class="hljs-attr">5px</span>', <span class="hljs-attr">padding:</span> '<span class="hljs-attr">5px</span>' }}&gt;</span>
                            main
                            <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                    )
                }
            <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span>
        )
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Content</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
                {
                    (value) =&gt; (
                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">border:</span> `<span class="hljs-attr">5px</span> <span class="hljs-attr">solid</span> ${<span class="hljs-attr">value.color</span>}`, <span class="hljs-attr">padding:</span> '<span class="hljs-attr">5px</span>' }}&gt;</span>
                            Content
                            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> value.changeColor('red')} style={{ color: 'red' }}&gt;红色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> value.changeColor('green')} style={{ color: 'green' }}&gt;绿色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                    )
                }
            <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span>

        )
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> };
    }
    changeColor = <span class="hljs-function">(<span class="hljs-params">color</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({ color });
    }
    render() {
        <span class="hljs-keyword">let</span> contextVal = { <span class="hljs-attr">changeColor</span>: <span class="hljs-keyword">this</span>.changeColor, <span class="hljs-attr">color</span>: <span class="hljs-keyword">this</span>.state.color };
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextVal}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">margin:</span> '<span class="hljs-attr">10px</span>', <span class="hljs-attr">border:</span> `<span class="hljs-attr">5px</span> <span class="hljs-attr">solid</span> ${<span class="hljs-attr">this.state.color</span>}`, <span class="hljs-attr">padding:</span> '<span class="hljs-attr">5px</span>', <span class="hljs-attr">width:</span> <span class="hljs-attr">200</span> }}&gt;</span>
                    page
                    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>

        )
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page</span> /&gt;</span></span>, root);
</code></pre>
<h3 id="t6112.2 src\constants.js">12.2 src\constants.js <a href="#t6112.2 src\constants.js"> # </a></h3>
<p>src\constants.js</p>
<pre><code class="lang-diff">export const REACT_TEXT = Symbol('REACT_TEXT');
export const REACT_FORWARD_REF_TYPE = Symbol('react.forward_ref');

export const PLACEMENT = 'PLACEMENT';
export const MOVE = 'MOVE';

<span class="hljs-addition">+export const REACT_PROVIDER = Symbol('react.provider');</span>
<span class="hljs-addition">+export const REACT_CONTEXT = Symbol('react.context');</span>
</code></pre>
<h3 id="t6212.3 src\Component.js">12.3 src\Component.js <a href="#t6212.3 src\Component.js"> # </a></h3>
<p>src\Component.js</p>
<pre><code class="lang-diff">import { findDOM, compareTwoVdom } from './react-dom';
export let updateQueue = {
    isBatchingUpdate: false,
    updaters: [],
    batchUpdate() {//批量更新
        for (let updater of updateQueue.updaters) {
            updater.updateComponent();
        }
        updateQueue.isBatchingUpdate = false;
        updateQueue.updaters.length = 0;
    }
}
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance;
        this.pendingStates = [];
        this.callbacks = [];
    }
    addState(partialState, callback) {
        this.pendingStates.push(partialState);///等待更新的或者说等待生效的状态
        if (typeof callback <span class="hljs-comment">=== 'function')</span>
            this.callbacks.push(callback);//状态更新后的回调
        this.emitUpdate();
    }
    emitUpdate(nextProps) {
        this.nextProps = nextProps;
        if (updateQueue.isBatchingUpdate) {
            updateQueue.updaters.push(this);
        } else {
            this.updateComponent();
        }
    }
    updateComponent() {
        let { classInstance, pendingStates } = this;
        if (this.nextProps || pendingStates.length &gt; 0) {
            shouldUpdate(classInstance, this.nextProps, this.getState());
        }
    }
    getState() {
        let { classInstance, pendingStates } = this;
        let { state } = classInstance;
        pendingStates.forEach((nextState) =&gt; {
            if (typeof nextState <span class="hljs-comment">=== 'function') {</span>
                nextState = nextState(state);
            }
            state = { ...state, ...nextState };
        });
        pendingStates.length = 0;
        return state;
    }
}
function shouldUpdate(classInstance, nextProps, nextState) {
    let willUpdate = true;
    if (classInstance.shouldComponentUpdate
        &amp;&amp; !classInstance.shouldComponentUpdate(nextProps, nextState)) {
        willUpdate = false;
    }
    if (willUpdate &amp;&amp; classInstance.componentWillUpdate) {
        classInstance.componentWillUpdate();
    }
    if (nextProps) {
        classInstance.props = nextProps;
    }
    classInstance.state = nextState;
    if (willUpdate) classInstance.forceUpdate();
}
export class Component {
    static isReactComponent = true;
    constructor(props) {
        this.props = props;
        this.state = {};
        this.updater = new Updater(this);
    }
    setState(partialState, callback) {
        this.updater.addState(partialState, callback);
    }
    forceUpdate() {
        let oldRenderVdom = this.oldRenderVdom;
        debugger
        let oldDOM = findDOM(oldRenderVdom);
<span class="hljs-addition">+       if (this.constructor.contextType) {</span>
<span class="hljs-addition">+           this.context = this.constructor.contextType._currentValue;</span>
<span class="hljs-addition">+       }</span>
        if (this.constructor.getDerivedStateFromProps) {
            let newState = this.constructor.getDerivedStateFromProps(this.props, this.state);
            if (newState)
                this.state = newState;
        }
        let extraArgs = this.getSnapshotBeforeUpdate &amp;&amp; this.getSnapshotBeforeUpdate();
        let newRenderVdom = this.render();
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom);
        this.oldRenderVdom = newRenderVdom;
        if (this.componentDidUpdate) {
            this.componentDidUpdate(this.props, this.state, extraArgs);
        }
    }
}
</code></pre>
<h3 id="t6312.4 src\react.js">12.4 src\react.js <a href="#t6312.4 src\react.js"> # </a></h3>
<p>src\react.js</p>
<pre><code class="lang-diff">import { wrapToVdom } from "./utils";
import { Component } from './Component';
<span class="hljs-addition">+import { REACT_FORWARD_REF_TYPE, REACT_FRAGMENT,REACT_CONTEXT, REACT_PROVIDER } from './constants';</span>
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
function createRef() {
  return { current: null };
}
function forwardRef(render) {
  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
  return elementType;
}
<span class="hljs-addition">+function createContext() {</span>
<span class="hljs-addition">+  let context = { $$typeof: REACT_CONTEXT };</span>
<span class="hljs-addition">+  context.Provider = {</span>
<span class="hljs-addition">+    $$typeof: REACT_PROVIDER,</span>
<span class="hljs-addition">+    _context: context</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  context.Consumer = {</span>
<span class="hljs-addition">+    $$typeof: REACT_CONTEXT,</span>
<span class="hljs-addition">+    _context: context</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return context;</span>
<span class="hljs-addition">+}</span>
const React = {
  createElement,
  Component,
  createRef,
  forwardRef,
  Fragment:REACT_FRAGMENT,
<span class="hljs-addition">+ createContext</span>
};
export default React;

</code></pre>
<h3 id="t6412.5 src\react-dom.js">12.5 src\react-dom.js <a href="#t6412.5 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { REACT_TEXT, REACT_FORWARD_REF_TYPE, PLACEMENT, MOVE, REACT_PROVIDER, REACT_CONTEXT,REACT_FRAGMENT } from "./constants";</span>
import { addEvent } from "./event";
import React from './react';
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
        if (newDOM._componentDidMount) newDOM._componentDidMount();
    }
}
export function createDOM(vdom) {
  let { type, props, ref } = vdom;
  let dom;
<span class="hljs-addition">+ if (type &amp;&amp; type.$$typeof === REACT_PROVIDER) {</span>
<span class="hljs-addition">+   return mountProviderComponent(vdom)</span>
<span class="hljs-addition">+ } else if (type &amp;&amp; type.$$typeof === REACT_CONTEXT) {</span>
<span class="hljs-addition">+   return mountContextComponent(vdom)</span>
<span class="hljs-addition">+ } else if (type &amp;&amp; type.$$typeof === REACT_FORWARD_REF_TYPE) {</span>
    return mountForwardComponent(vdom);
  } else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    dom = document.createDocumentFragment();
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
       return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      props.children.mountIndex = 0;
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if (ref) ref.current = dom;
  return dom;
}
<span class="hljs-addition">+function mountProviderComponent(vdom) {</span>
<span class="hljs-addition">+  let { type, props } = vdom;</span>
<span class="hljs-addition">+  let context = type._context;</span>
<span class="hljs-addition">+  context._currentValue = props.value;</span>
<span class="hljs-addition">+  let renderVdom = props.children;</span>
<span class="hljs-addition">+  vdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+  return createDOM(renderVdom);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountContextComponent(vdom) {</span>
<span class="hljs-addition">+  let { type, props } = vdom;</span>
<span class="hljs-addition">+  let context = type._context;</span>
<span class="hljs-addition">+  let renderVdom = props.children(context._currentValue);</span>
<span class="hljs-addition">+  vdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+  return createDOM(renderVdom);</span>
<span class="hljs-addition">+}</span>
function mountForwardComponent(vdom) {
  let { type, props, ref } = vdom;
  let renderVdom = type.render(props, ref);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props, ref } = vdom;
  let classInstance = new type(props);
<span class="hljs-addition">+ if (type.contextType) {</span>
<span class="hljs-addition">+   classInstance.context = type.contextType._currentValue;</span>
<span class="hljs-addition">+ }</span>
  vdom.classInstance = classInstance;
  if (ref) ref.current = classInstance;
  if (classInstance.componentWillMount) classInstance.componentWillMount();
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom  = renderVdom;
  let dom = createDOM(renderVdom);
  if (classInstance.componentDidMount)
    dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom) {
    if (!vdom) return null;
    if (vdom.dom) {//vdom={type:'h1'}
        return vdom.dom;
    } else {
        let renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom;
        return findDOM(renderVdom);
    }
}
function unMountVdom(vdom) {
    let { type, props, ref } = vdom;
    let currentDOM = findDOM(vdom);//获取此虚拟DOM对应的真实DOM
    //vdom可能是原生组件span 类组件 classComponent 也可能是函数组件Function
    if (vdom.classInstance &amp;&amp; vdom.classInstance.componentWillUnmount) {
        vdom.classInstance.componentWillUnmount();
    }
    if (ref) {
        ref.current = null;
    }
    //如果此虚拟DOM有子节点的话，递归全部删除
    if (props.children) {
        //得到儿子的数组
        let children = Array.isArray(props.children) ? props.children : [props.children];
        children.forEach(unMountVdom);
    }
    //把自己这个虚拟DOM对应的真实DOM从界面删除
    if (currentDOM) currentDOM.parentNode.removeChild(currentDOM);
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom, nextDOM) {
  if (!oldVdom &amp;&amp; !newVdom) {
    //老和新都是没有
    return;
  } else if (!!oldVdom &amp;&amp; !newVdom) {
    //老有新没有
    unMountVdom(oldVdom);
  } else if (!oldVdom &amp;&amp; !!newVdom) {
    //老没有新的有
    let newDOM = createDOM(newVdom);
    if (nextDOM) parentDOM.insertBefore(newDOM, nextDOM);
    else parentDOM.appendChild(newDOM);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
    return;
  } else if (!!oldVdom &amp;&amp; !!newVdom &amp;&amp; oldVdom.type !== newVdom.type) {
    //新老都有，但类型不同
    let newDOM = createDOM(newVdom);
    unMountVdom(oldVdom);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
  } else {
    updateElement(oldVdom, newVdom);
  }
}
function updateElement(oldVdom, newVdom) {
<span class="hljs-addition">+ if (oldVdom.type.$$typeof === REACT_CONTEXT) {</span>
<span class="hljs-addition">+   updateContextComponent(oldVdom, newVdom);</span>
<span class="hljs-addition">+ } else if (oldVdom.type.$$typeof === REACT_PROVIDER) {</span>
<span class="hljs-addition">+   updateProviderComponent(oldVdom, newVdom);</span>
<span class="hljs-addition">+ } else if (oldVdom.type === REACT_TEXT &amp;&amp; newVdom.type === REACT_TEXT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    if (oldVdom.props.content !== newVdom.props.content) {
      currentDOM.textContent = newVdom.props.content;
    }
    return;
  } else if (oldVdom.type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'string') {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateProps(currentDOM, oldVdom.props, newVdom.props);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'function') {</span>
    if (oldVdom.type.isReactComponent) {
      newVdom.classInstance = oldVdom.classInstance;
      updateClassComponent(oldVdom, newVdom);
    } else {
       updateFunctionComponent(oldVdom, newVdom);
    }
  }
}
<span class="hljs-addition">+function updateProviderComponent(oldVdom, newVdom) {</span>
<span class="hljs-addition">+  let parentDOM = findDOM(oldVdom).parentNode;</span>
<span class="hljs-addition">+  let { type, props } = newVdom;</span>
<span class="hljs-addition">+  let context = type._context;</span>
<span class="hljs-addition">+  context._currentValue = props.value;</span>
<span class="hljs-addition">+  let renderVdom = props.children;</span>
<span class="hljs-addition">+  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);</span>
<span class="hljs-addition">+  newVdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateContextComponent(oldVdom, newVdom) {</span>
<span class="hljs-addition">+  let parentDOM = findDOM(oldVdom).parentNode;</span>
<span class="hljs-addition">+  let { type, props } = newVdom;</span>
<span class="hljs-addition">+  let context = type._context;</span>
<span class="hljs-addition">+  let renderVdom = props.children(context._currentValue);</span>
<span class="hljs-addition">+  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);</span>
<span class="hljs-addition">+  newVdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+}</span>
function updateFunctionComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let newRenderVdom = type(props);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom);
  newVdom.oldRenderVdom = newRenderVdom;
}
function updateClassComponent(oldVdom, newVdom) {
  let classInstance = newVdom.classInstance = oldVdom.classInstance;
  if (classInstance.componentWillReceiveProps) {
    classInstance.componentWillReceiveProps();
  }
  classInstance.updater.emitUpdate(newVdom.props);
}
function updateChildren(parentDOM, oldVChildren, newVChildren) {
  oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : oldVChildren ? [oldVChildren] : [];
  newVChildren = Array.isArray(newVChildren) ? newVChildren : newVChildren ? [newVChildren] : [];
  let keyedOldMap = {};
  let lastPlacedIndex = 0;
  oldVChildren.forEach((oldVChild, index) =&gt; {
    let oldKey = oldVChild.key ? oldVChild.key : index;
    keyedOldMap[oldKey] = oldVChild;
  });
  let patch = [];
  newVChildren.forEach((newVChild, index) =&gt; {
    newVChild.mountIndex = index;
    let newKey = newVChild.key ? newVChild.key : index;
    let oldVChild = keyedOldMap[newKey];
    if (oldVChild) {
      updateElement(oldVChild, newVChild);
      if (oldVChild.mountIndex &lt; lastPlacedIndex) {
        patch.push({
          type: MOVE,
          oldVChild,
          newVChild,
          mount<span class="hljs-comment">Index: index</span>
        });
      }
      delete keyedOldMap[newKey];
      lastPlacedIndex = Math.max(lastPlacedIndex, oldVChild.mountIndex);
    } else {
      patch.push({
        type: PLACEMENT,
        newVChild,
        mount<span class="hljs-comment">Index: index</span>
      });
    }
  });
  let moveVChild = patch.filter(action =&gt; action.type <span class="hljs-comment">=== MOVE).map(action =&gt; action.oldVChild);</span>
  Object.values(keyedOldMap).concat(moveVChild).forEach((oldVChild) =&gt; {
    let currentDOM = findDOM(oldVChild);
    parentDOM.removeChild(currentDOM);
  });
  patch.forEach(action =&gt; {
    let { type, oldVChild, newVChild, mountIndex } = action;
    let childNodes = parentDOM.childNodes;
    if (type <span class="hljs-comment">=== PLACEMENT) {</span>
      let newDOM = createDOM(newVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(newDOM, childNode);
      } else {
        parentDOM.appendChild(newDOM);
      }
    } else if (type <span class="hljs-comment">=== MOVE) {</span>
      let oldDOM = findDOM(oldVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(oldDOM, childNode);
      } else {
        parentDOM.appendChild(oldDOM);
      }
    }
  });
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    childVdom.mountIndex = i;
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;

</code></pre>
<h2 id="t6513. 高阶组件">13. 高阶组件 <a href="#t6513. 高阶组件"> # </a></h2>
<ul>
<li>高阶组件就是一个函数，传给它一个组件，它返回一个新的组件</li>
<li>高阶组件的作用其实就是为了组件之间的代码复用</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> NewComponent = higherOrderComponent(OldComponent)
</code></pre>
<h3 id="t6613.1 cra支持装饰器">13.1 cra支持装饰器 <a href="#t6613.1 cra支持装饰器"> # </a></h3>
<h4 id="t6713.1.1 安装">13.1.1 安装 <a href="#t6713.1.1 安装"> # </a></h4>
<pre><code class="lang-js">npm i react-app-rewired customize-cra @babel/plugin-proposal-decorators -D
</code></pre>
<h4 id="t6813.1.2 修改package.json">13.1.2 修改package.json <a href="#t6813.1.2 修改package.json"> # </a></h4>
<pre><code class="lang-json">  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-app-rewired eject"
  }
</code></pre>
<h4 id="t6913.1.3 config-overrides.js">13.1.3 config-overrides.js <a href="#t6913.1.3 config-overrides.js"> # </a></h4>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> {override,addBabelPlugin} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'customize-cra'</span>);

<span class="hljs-built_in">module</span>.exports = override(
  addBabelPlugin( [
    <span class="hljs-string">"@babel/plugin-proposal-decorators"</span>, { <span class="hljs-string">"legacy"</span>: <span class="hljs-literal">true</span> }
  ])
)
</code></pre>
<h4 id="t7013.1.4 jsconfig.json">13.1.4 jsconfig.json <a href="#t7013.1.4 jsconfig.json"> # </a></h4>
<pre><code class="lang-json">{
  <span class="hljs-attr">"compilerOptions"</span>: {
     <span class="hljs-attr">"experimentalDecorators"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h3 id="t7113.2 属性代理">13.2 属性代理 <a href="#t7113.2 属性代理"> # </a></h3>
<ul>
<li>基于属性代理：操作组件的props</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">const</span> loading = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span><span class="hljs-function"><span class="hljs-params">OldComponent</span> =&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
        render(){
            <span class="hljs-keyword">const</span> state = {
                <span class="hljs-attr">show</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
                    <span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
                    div.innerHTML = <span class="hljs-string">`&lt;p id="loading" style="position:absolute;top:100px;z-index:10;background-color:black"&gt;<span class="hljs-subst">${message}</span>&lt;/p&gt;`</span>;
                    <span class="hljs-built_in">document</span>.body.appendChild(div);
                },
                <span class="hljs-attr">hide</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loading'</span>).remove();
                }
            }
            <span class="hljs-keyword">return</span>  (
                <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">OldComponent</span> {<span class="hljs-attr">...this.props</span>} {<span class="hljs-attr">...state</span>} {<span class="hljs-attr">...</span>{<span class="hljs-attr">...this.props</span>,<span class="hljs-attr">...state</span>}}/&gt;</span></span>
            )
        }
    }
}
@loading(<span class="hljs-string">'正在加载中'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
  render(){
     <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.props.show}</span>&gt;</span>show<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.props.hide}</span>&gt;</span>hide<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}
<span class="hljs-keyword">let</span> LoadingHello  = loading(<span class="hljs-string">'正在加载'</span>)(Hello);

ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoadingHello</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t7213.3 反向继承">13.3 反向继承 <a href="#t7213.3 反向继承"> # </a></h3>
<ul>
<li>基于反向继承：拦截生命周期、state、渲染过程</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    state = {<span class="hljs-attr">name</span>:<span class="hljs-string">'张三'</span>}
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Button componentWillMount'</span>);
    }
    componentDidMount(){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Button componentDidMount'</span>);
    }
    render(){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Button render'</span>);
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{this.state.name}</span> <span class="hljs-attr">title</span>=<span class="hljs-string">{this.props.title}/</span>&gt;</span></span>
    }
}
<span class="hljs-keyword">const</span> wrapper = <span class="hljs-function"><span class="hljs-params">OldComponent</span> =&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OldComponent</span></span>{
        state = {<span class="hljs-attr">number</span>:<span class="hljs-number">0</span>}
        componentWillMount(){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'WrapperButton componentWillMount'</span>);
             <span class="hljs-keyword">super</span>.componentWillMount();
        }
        componentDidMount(){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'WrapperButton componentDidMount'</span>);
             <span class="hljs-keyword">super</span>.componentDidMount();
        }
        handleClick = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
            <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">number</span>:<span class="hljs-keyword">this</span>.state.number+<span class="hljs-number">1</span>});
        }
        render(){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'WrapperButton render'</span>);
            <span class="hljs-keyword">let</span> renderElement = <span class="hljs-keyword">super</span>.render();
            <span class="hljs-keyword">let</span> newProps = {
                ...renderElement.props,
                ...this.state,
                <span class="hljs-attr">onClick</span>:<span class="hljs-keyword">this</span>.handleClick
            }
            <span class="hljs-keyword">return</span>  React.cloneElement(
                renderElement,
                newProps,
                <span class="hljs-keyword">this</span>.state.number
            );
        }
    }
}
<span class="hljs-keyword">let</span> WrappedButton = wrapper(Button);
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedButton</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"标题"</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<p>src\react.js</p>
<pre><code class="lang-diff">import { wrapToVdom } from "./utils";
import { Component } from './Component';
import { REACT_FORWARD_REF_TYPE, REACT_FRAGMENT,REACT_CONTEXT, REACT_PROVIDER } from './constants';
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
function createRef() {
  return { current: null };
}
function forwardRef(render) {
  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
  return elementType;
}
function createContext() {
  let context = { $$typeof: REACT_CONTEXT };
  context.Provider = {
    $$typeof: REACT_PROVIDER,
    _context: context
  }
  context.Consumer = {
    $$typeof: REACT_CONTEXT,
    _context: context
  }
  return context;
}
<span class="hljs-addition">+function cloneElement(element, newProps, ...newChildren) {</span>
<span class="hljs-addition">+  let oldChildren = element.props &amp;&amp; element.props.children;</span>
<span class="hljs-addition">+  let children = [...(Array.isArray(oldChildren) ? oldChildren : [oldChildren]), ...newChildren]</span>
<span class="hljs-addition">+    .filter(item =&gt; item !== undefined)</span>
<span class="hljs-addition">+    .map(wrapToVdom);</span>
<span class="hljs-addition">+  if (children.length === 1) children = children[0];</span>
<span class="hljs-addition">+  let props = { ...element.props, ...newProps, children };</span>
<span class="hljs-addition">+  return { ...element, props };</span>
<span class="hljs-addition">+}</span>
const React = {
  createElement,
  Component,
  createRef,
  forwardRef,
  Fragment:REACT_FRAGMENT,
  createContext,
<span class="hljs-addition">+ cloneElement</span>
};
export default React;
</code></pre>
<h2 id="t7314. render props">14. render props <a href="#t7314. render props"> # </a></h2>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/render-props.html">render-props</a></li>
<li><code>render prop</code> 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</li>
<li>具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑</li>
<li>render prop 是一个用于告知组件需要渲染什么内容的函数 prop</li>
<li>这也是逻辑复用的一种方式</li>
</ul>
<h3 id="t7414.1 原生实现">14.1 原生实现 <a href="#t7414.1 原生实现"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MouseTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };
    }

    handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">x</span>: event.clientX,
            <span class="hljs-attr">y</span>: event.clientY
        });
    }

    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onMouseMove</span>=<span class="hljs-string">{this.handleMouseMove}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>移动鼠标!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前的鼠标位置是 ({this.state.x}, {this.state.y})<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MouseTracker</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t7514.2  children">14.2  children <a href="#t7514.2  children"> # </a></h3>
<ul>
<li>children是一个渲染的方法</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MouseTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };
    }

    handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">x</span>: event.clientX,
            <span class="hljs-attr">y</span>: event.clientY
        });
    }

    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onMouseMove</span>=<span class="hljs-string">{this.handleMouseMove}</span>&gt;</span>
                {this.props.children(this.state)}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MouseTracker</span> &gt;</span>
    {
        (props) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>移动鼠标!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前的鼠标位置是 ({props.x}, {props.y})<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )
    }
<span class="hljs-tag">&lt;/<span class="hljs-name">MouseTracker</span> &gt;</span>, document.getElementById('root'));
</span></code></pre>
<h3 id="t7614.3 render属性">14.3 render属性 <a href="#t7614.3 render属性"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MouseTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };
    }

    handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">x</span>: event.clientX,
            <span class="hljs-attr">y</span>: event.clientY
        });
    }

    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onMouseMove</span>=<span class="hljs-string">{this.handleMouseMove}</span>&gt;</span>
                {this.props.render(this.state)}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
}

ReactDOM.render(&lt; MouseTracker render={params =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>移动鼠标!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前的鼠标位置是 ({params.x}, {params.y})<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
)} /&gt;, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t7714.4 HOC">14.4 HOC <a href="#t7714.4 HOC"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withTracker</span>(<span class="hljs-params">OldComponent</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MouseTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{
    <span class="hljs-keyword">constructor</span>(props){
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.state = {<span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">0</span>};
    }
    handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>{
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">x</span>:event.clientX,
            <span class="hljs-attr">y</span>:event.clientY
        });
    }
    render(){
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onMouseMove</span> = <span class="hljs-string">{this.handleMouseMove}</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">OldComponent</span> {<span class="hljs-attr">...this.state</span>}/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
 }
}
<span class="hljs-comment">//render</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Show</span>(<span class="hljs-params">props</span>)</span>{
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>请移动鼠标<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前鼠标的位置是: x:{props.x} y:{props.y}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
    )
}
<span class="hljs-keyword">let</span> HighShow = withTracker(Show);
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HighShow</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h2 id="t7815.性能优化">15.性能优化 <a href="#t7815.性能优化"> # </a></h2>
<h3 id="t7915.1 src\index.js">15.1 src\index.js <a href="#t7915.1 src\index.js"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>{
    render() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ClassCounter render'</span>);
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>ClassCounter:{this.props.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FunctionCounter</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FunctionCounter render'</span>); <span class="hljs-keyword">debugger</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>FunctionCounter:{props.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
<span class="hljs-keyword">const</span> MemoFunctionCounter = React.memo(FunctionCounter);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> }
    amountRef = React.createRef()
    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> nextNumber = <span class="hljs-keyword">this</span>.state.number + <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.amountRef.current.value);
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">number</span>: nextNumber });
    }
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ClassCounter</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{this.state.number}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">MemoFunctionCounter</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{this.state.number}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.amountRef}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t8015.2 src\constants.js">15.2 src\constants.js <a href="#t8015.2 src\constants.js"> # </a></h3>
<p>src\constants.js</p>
<pre><code class="lang-diff">export const REACT_TEXT = Symbol('REACT_TEXT');
export const REACT_FORWARD_REF_TYPE = Symbol('react.forward_ref');

export const PLACEMENT = 'PLACEMENT';
export const MOVE = 'MOVE';

export const REACT_CONTEXT = Symbol('react.context');
export const REACT_PROVIDER = Symbol('react.provider');
<span class="hljs-addition">+export const REACT_MEMO = Symbol('react.memo')</span>
</code></pre>
<h3 id="t8115.3 src\utils.js">15.3 src\utils.js <a href="#t8115.3 src\utils.js"> # </a></h3>
<p>src\utils.js</p>
<pre><code class="lang-diff">import { REACT_TEXT } from "./constants";
export function wrapToVdom(element) {
  return typeof element <span class="hljs-comment">=== "string" || typeof element === "number"</span>
    ? { type: REACT_TEXT, props: { content: element } }
    : element;
}

export function isFunction(obj) {
  return typeof obj <span class="hljs-comment">=== 'function';</span>
}

<span class="hljs-addition">+export function shallowEqual(obj1, obj2) {</span>
<span class="hljs-addition">+  if (obj1 === obj2) {</span>
<span class="hljs-addition">+    return true;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (typeof obj1 != "object" || obj1 === null || typeof obj2 != "object" || obj2 === null) {</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  let keys1 = Object.keys(obj1);</span>
<span class="hljs-addition">+  let keys2 = Object.keys(obj2);</span>
<span class="hljs-addition">+  if (keys1.length !== keys2.length) {</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  for (let key of keys1) {</span>
<span class="hljs-addition">+    if (!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key]) {</span>
<span class="hljs-addition">+      return false;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return true;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t8215.4 src\react.js">15.4 src\react.js <a href="#t8215.4 src\react.js"> # </a></h3>
<p>src\react.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { wrapToVdom, shallowEqual } from "./utils";</span>
import { Component } from './Component';
<span class="hljs-addition">+import { REACT_FORWARD_REF_TYPE,REACT_FRAGMENT, REACT_CONTEXT, REACT_PROVIDER, REACT_MEMO } from './constants';</span>
function createElement(type, config, children) {
  let ref;
  let key;
  if (config) {
    delete config.__source;
    delete config.__self;
    ref = config.ref;
    delete config.ref;
    key = config.key;
    delete config.key;
  }
  let props = { ...config };
  if (arguments.length &gt; 3) {
    props.children = Array.prototype.slice.call(arguments, 2).map(wrapToVdom);
  } else {
    props.children = wrapToVdom(children);
  }
  return {
    type,
    ref,
    key,
    props,
  };
}
function createRef() {
  return { current: null };
}
function forwardRef(render) {
  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
  return elementType;
}
function createContext() {
  let context = { $$typeof: REACT_CONTEXT };
  context.Provider = {
    $$typeof: REACT_PROVIDER,
    _context: context
  }
  context.Consumer = {
    $$typeof: REACT_CONTEXT,
    _context: context
  }
  return context;
}
function cloneElement(element, newProps, ...newChildren) {
  let oldChildren = element.props &amp;&amp; element.props.children;
  let children = [...(Array.isArray(oldChildren) ? oldChildren : [oldChildren]), ...newChildren]
    .filter(item =&gt; item !== undefined)
    .map(wrapToVdom);
  if (children.length <span class="hljs-comment">=== 1) children = children[0];</span>
  let props = { ...element.props, ...newProps, children };
  return { ...element, props };
}
<span class="hljs-addition">+class PureComponent extends Component {</span>
<span class="hljs-addition">+  shouldComponentUpdate(newProps, nextState) {</span>
<span class="hljs-addition">+    return !shallowEqual(this.props, newProps) || !shallowEqual(this.state, nextState);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function memo(type, compare = shallowEqual) {</span>
<span class="hljs-addition">+  return {</span>
<span class="hljs-addition">+    $$typeof: REACT_MEMO,</span>
<span class="hljs-addition">+    type,</span>
<span class="hljs-addition">+    compare</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
const React = {
  createElement,
  Component,
  createRef,
  forwardRef,
  Fragment:REACT_FRAGMENT,
  createContext,
  cloneElement,
  PureComponent,
<span class="hljs-addition">+ memo</span>
};
export default React;
</code></pre>
<h3 id="t8315.5 src\react-dom.js">15.5 src\react-dom.js <a href="#t8315.5 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { REACT_TEXT, REACT_FORWARD_REF_TYPE, PLACEMENT, MOVE, REACT_FRAGMENT,REACT_PROVIDER, REACT_CONTEXT, REACT_MEMO } from "./constants";</span>
import { addEvent } from "./event";
import React from './react';
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
        if (newDOM._componentDidMount) newDOM._componentDidMount();
    }
}
export function createDOM(vdom) {
  let { type, props, ref } = vdom;
  let dom;
<span class="hljs-addition">+  if (type &amp;&amp; type.$$typeof === REACT_MEMO) {</span>
<span class="hljs-addition">+    return mountMemoComponent(vdom);</span>
<span class="hljs-addition">+  } else if (type &amp;&amp; type.$$typeof === REACT_PROVIDER) {</span>
    return mountProviderComponent(vdom)
  } else if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_CONTEXT) {</span>
    return mountContextComponent(vdom)
  } else if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_FORWARD_REF_TYPE) {</span>
    return mountForwardComponent(vdom);
  } else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  } else if (type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    dom = document.createDocumentFragment();
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
       return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      props.children.mountIndex = 0;
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if (ref) ref.current = dom;
  return dom;
}

<span class="hljs-addition">+function mountMemoComponent(vdom) {</span>
<span class="hljs-addition">+  let { type, props } = vdom;</span>
<span class="hljs-addition">+  let renderVdom = type.type(props);</span>
<span class="hljs-addition">+  vdom.prevProps = props;</span>
<span class="hljs-addition">+  vdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+  return createDOM(renderVdom);</span>
<span class="hljs-addition">+}</span>
function mountProviderComponent(vdom) {
  let { type, props } = vdom;
  let context = type._context;
  context._currentValue = props.value;
  let renderVdom = props.children;
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountContextComponent(vdom) {
  let { type, props } = vdom;
  let context = type._context;
  let renderVdom = props.children(context._currentValue);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountForwardComponent(vdom) {
  let { type, props, ref } = vdom;
  let renderVdom = type.render(props, ref);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props, ref } = vdom;
  let classInstance = new type(props);
  if (type.contextType) {
    classInstance.context = type.contextType._currentValue;
  }
  vdom.classInstance = classInstance;
  if (ref) ref.current = classInstance;
  if (classInstance.componentWillMount) classInstance.componentWillMount();
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom  = renderVdom;
  let dom = createDOM(renderVdom);
  if (classInstance.componentDidMount)
    dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom) {
    if (!vdom) return null;
    if (vdom.dom) {//vdom={type:'h1'}
        return vdom.dom;
    } else {
        let renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom;
        return findDOM(renderVdom);
    }
}
function unMountVdom(vdom) {
    let { type, props, ref } = vdom;
    let currentDOM = findDOM(vdom);//获取此虚拟DOM对应的真实DOM
    //vdom可能是原生组件span 类组件 classComponent 也可能是函数组件Function
    if (vdom.classInstance &amp;&amp; vdom.classInstance.componentWillUnmount) {
        vdom.classInstance.componentWillUnmount();
    }
    if (ref) {
        ref.current = null;
    }
    //如果此虚拟DOM有子节点的话，递归全部删除
    if (props.children) {
        //得到儿子的数组
        let children = Array.isArray(props.children) ? props.children : [props.children];
        children.forEach(unMountVdom);
    }
    //把自己这个虚拟DOM对应的真实DOM从界面删除
    if (currentDOM) currentDOM.parentNode.removeChild(currentDOM);
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom, nextDOM) {
  if (!oldVdom &amp;&amp; !newVdom) {
    //老和新都是没有
    return;
  } else if (!!oldVdom &amp;&amp; !newVdom) {
    //老有新没有
    unMountVdom(oldVdom);
  } else if (!oldVdom &amp;&amp; !!newVdom) {
    //老没有新的有
    let newDOM = createDOM(newVdom);
    if (nextDOM) parentDOM.insertBefore(newDOM, nextDOM);
    else parentDOM.appendChild(newDOM);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
    return;
  } else if (!!oldVdom &amp;&amp; !!newVdom &amp;&amp; oldVdom.type !== newVdom.type) {
    //新老都有，但类型不同
    let newDOM = createDOM(newVdom);
    unMountVdom(oldVdom);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
  } else {
    updateElement(oldVdom, newVdom);
  }
}
function updateElement(oldVdom, newVdom) {
<span class="hljs-addition">+  if (oldVdom.type &amp;&amp; oldVdom.type.$$typeof === REACT_MEMO) {</span>
<span class="hljs-addition">+    updateMemoComponent(oldVdom, newVdom);</span>
  } else if (oldVdom.type.$$typeof <span class="hljs-comment">=== REACT_CONTEXT) {</span>
    updateContextComponent(oldVdom, newVdom);
  } else if (oldVdom.type.$$typeof <span class="hljs-comment">=== REACT_PROVIDER) {</span>
    updateProviderComponent(oldVdom, newVdom);
  } else if (oldVdom.type <span class="hljs-comment">=== REACT_TEXT &amp;&amp; newVdom.type === REACT_TEXT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    if (oldVdom.props.content !== newVdom.props.content) {
      currentDOM.textContent = newVdom.props.content;
    }
    return;
  }  else if (oldVdom.type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  }else if (typeof oldVdom.type <span class="hljs-comment">=== 'string') {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateProps(currentDOM, oldVdom.props, newVdom.props);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'function') {</span>
    if (oldVdom.type.isReactComponent) {
      newVdom.classInstance = oldVdom.classInstance;
      updateClassComponent(oldVdom, newVdom);
    } else {
      updateFunctionComponent(oldVdom, newVdom);
    }
  }
}
<span class="hljs-addition">+function updateMemoComponent(oldVdom, newVdom) {</span>
<span class="hljs-addition">+  let { type, prevProps } = oldVdom;</span>
<span class="hljs-addition">+  if (!type.compare(prevProps, newVdom.props)) {</span>
<span class="hljs-addition">+    let oldDOM = findDOM(oldVdom);</span>
<span class="hljs-addition">+    let parentDOM = oldDOM.parentNode;</span>
<span class="hljs-addition">+    let { type, props } = newVdom;</span>
<span class="hljs-addition">+    let renderVdom = type.type(props);</span>
<span class="hljs-addition">+    compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);</span>
<span class="hljs-addition">+    newVdom.prevProps = props;</span>
<span class="hljs-addition">+    newVdom.oldRenderVdom = renderVdom;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    newVdom.prevProps = prevProps;</span>
<span class="hljs-addition">+    newVdom.oldRenderVdom = oldVdom.oldRenderVdom;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function updateProviderComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let context = type._context;
  context._currentValue = props.value;
  let renderVdom = props.children;
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);
  newVdom.oldRenderVdom = renderVdom;
}
function updateContextComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let context = type._context;
  let renderVdom = props.children(context._currentValue);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);
  newVdom.oldRenderVdom = renderVdom;
}
function updateFunctionComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let newRenderVdom = type(props);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom);
  newVdom.oldRenderVdom = newRenderVdom;
}
function updateClassComponent(oldVdom, newVdom) {
  let classInstance = newVdom.classInstance = oldVdom.classInstance;
  if (classInstance.componentWillReceiveProps) {
    classInstance.componentWillReceiveProps();
  }
  classInstance.updater.emitUpdate(newVdom.props);
}
function updateChildren(parentDOM, oldVChildren, newVChildren) {
  oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : oldVChildren ? [oldVChildren] : [];
  newVChildren = Array.isArray(newVChildren) ? newVChildren : newVChildren ? [newVChildren] : [];
  let keyedOldMap = {};
  let lastPlacedIndex = 0;
  oldVChildren.forEach((oldVChild, index) =&gt; {
    let oldKey = oldVChild.key ? oldVChild.key : index;
    keyedOldMap[oldKey] = oldVChild;
  });
  let patch = [];
  newVChildren.forEach((newVChild, index) =&gt; {
    newVChild.mountIndex = index;
    let newKey = newVChild.key ? newVChild.key : index;
    let oldVChild = keyedOldMap[newKey];
    if (oldVChild) {
      updateElement(oldVChild, newVChild);
      if (oldVChild.mountIndex &lt; lastPlacedIndex) {
        patch.push({
          type: MOVE,
          oldVChild,
          newVChild,
          mount<span class="hljs-comment">Index: index</span>
        });
      }
      delete keyedOldMap[newKey];
      lastPlacedIndex = Math.max(lastPlacedIndex, oldVChild.mountIndex);
    } else {
      patch.push({
        type: PLACEMENT,
        newVChild,
        mount<span class="hljs-comment">Index: index</span>
      });
    }
  });
  let moveVChild = patch.filter(action =&gt; action.type <span class="hljs-comment">=== MOVE).map(action =&gt; action.oldVChild);</span>
  Object.values(keyedOldMap).concat(moveVChild).forEach((oldVChild) =&gt; {
    let currentDOM = findDOM(oldVChild);
    parentDOM.removeChild(currentDOM);
  });
  patch.forEach(action =&gt; {
    let { type, oldVChild, newVChild, mountIndex } = action;
    let childNodes = parentDOM.childNodes;
    if (type <span class="hljs-comment">=== PLACEMENT) {</span>
      let newDOM = createDOM(newVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(newDOM, childNode);
      } else {
        parentDOM.appendChild(newDOM);
      }
    } else if (type <span class="hljs-comment">=== MOVE) {</span>
      let oldDOM = findDOM(oldVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(oldDOM, childNode);
      } else {
        parentDOM.appendChild(oldDOM);
      }
    }
  });
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    childVdom.mountIndex = i;
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
};
export default ReactDOM;

</code></pre>
<h2 id="t8416.Portal">16.Portal <a href="#t8416.Portal"> # </a></h2>
<ul>
<li>React v16增加了对Portal的直接支持</li>
<li>它可以把JSX渲染到一个单独的DOM节点中</li>
</ul>
<h3 id="t8516.1 src\index.js">16.1 src\index.js <a href="#t8516.1 src\index.js"> # </a></h3>
<p>src\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'./react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'./react-dom'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props);
        <span class="hljs-keyword">this</span>.node = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        <span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-keyword">this</span>.node);
    }
    render() {
        <span class="hljs-keyword">return</span> ReactDOM.createPortal(
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
                {this.props.children}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
            <span class="hljs-keyword">this</span>.node
        );
    }
    componentWillUnmount() {
        <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-keyword">this</span>.node);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span>&gt;</span>模态窗<span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
    }
}
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
</code></pre>
<h3 id="t8616.2 src\react-dom.js">16.2 src\react-dom.js <a href="#t8616.2 src\react-dom.js"> # </a></h3>
<p>src\react-dom.js</p>
<pre><code class="lang-diff">import { REACT_TEXT, REACT_FORWARD_REF_TYPE, PLACEMENT, MOVE, REACT_FRAGMENT,REACT_PROVIDER, REACT_CONTEXT, REACT_MEMO } from "./constants";
import { addEvent } from "./event";
import React from './react';
function render(vdom, parentDOM) {
    let newDOM = createDOM(vdom)
    if (newDOM) {
        parentDOM.appendChild(newDOM);
        if (newDOM._componentDidMount) newDOM._componentDidMount();
    }
}
export function createDOM(vdom) {
  let { type, props, ref } = vdom;
  let dom;
  if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_MEMO) {</span>
    return mountMemoComponent(vdom);
  } else if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_PROVIDER) {</span>
    return mountProviderComponent(vdom)
  } else if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_CONTEXT) {</span>
    return mountContextComponent(vdom)
  } else if (type &amp;&amp; type.$$typeof <span class="hljs-comment">=== REACT_FORWARD_REF_TYPE) {</span>
    return mountForwardComponent(vdom);
  } else if (type <span class="hljs-comment">=== REACT_TEXT) {</span>
    dom = document.createTextNode(props.content);
  }else if (type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    dom = document.createDocumentFragment();
  } else if (typeof type <span class="hljs-comment">=== "function") {</span>
    if (type.isReactComponent) {
      return mountClassComponent(vdom);
    } else {
      return mountFunctionComponent(vdom);
    }
  } else {
    dom = document.createElement(type);
  }
  if (props) {
    updateProps(dom, {}, props);
    if (typeof props.children == "object" &amp;&amp; props.children.type) {
      props.children.mountIndex = 0;
      mount(props.children, dom);
    } else if (Array.isArray(props.children)) {
      reconcileChildren(props.children, dom);
    }
  }
  vdom.dom = dom;
  if (ref) ref.current = dom;
  return dom;
}

function mountMemoComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type.type(props);
  vdom.prevProps = props;
  vdom.oldRenderVdom = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;  </span>
  return createDOM(renderVdom);
}
function mountProviderComponent(vdom) {
  let { type, props } = vdom;
  let context = type._context;
  context._currentValue = props.value;
  let renderVdom = props.children;
  vdom.oldRenderVdom = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;  </span>
  return createDOM(renderVdom);
}
function mountContextComponent(vdom) {
  let { type, props } = vdom;
  let context = type._context;
  let renderVdom = props.children(context._currentValue);
  vdom.oldRenderVdom = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;  </span>
  return createDOM(renderVdom);
}
function mountForwardComponent(vdom) {
  let { type, props, ref } = vdom;
  let renderVdom = type.render(props, ref);
  vdom.oldRenderVdom = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;  </span>
  return createDOM(renderVdom);
}
function mountClassComponent(vdom) {
  let { type, props, ref } = vdom;
  let classInstance = new type(props);
  if (type.contextType) {
    classInstance.context = type.contextType._currentValue;
  }
  vdom.classInstance = classInstance;
  if (ref) ref.current = classInstance;
  if (classInstance.componentWillMount) classInstance.componentWillMount();
  let renderVdom = classInstance.render();
  classInstance.oldRenderVdom  = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;</span>
  let dom = createDOM(renderVdom);
  if (classInstance.componentDidMount)
    dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
  return dom;
}
function mountFunctionComponent(vdom) {
  let { type, props } = vdom;
  let renderVdom = type(props);
  vdom.oldRenderVdom = renderVdom;
<span class="hljs-addition">+ if (!renderVdom) return null;</span>
  return createDOM(renderVdom);
}
function updateProps(dom, oldProps={}, newProps={}) {
    for (let key in newProps) {
        if (key <span class="hljs-comment">=== 'children') {</span>
            continue;
        } else if (key <span class="hljs-comment">=== 'style') {</span>
            let styleObj = newProps[key];
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr];
            }
        } else if (key.startsWith('on')) {
            addEvent(dom, key.toLocaleLowerCase(), newProps[key]);
        } else {
            dom[key] = newProps[key];
        }
    }
    for(let key in oldProps){
        if(!newProps.hasOwnProperty(key)){
            dom[key] = null;
        }
    }
}
export function findDOM(vdom) {
    if (!vdom) return null;
    if (vdom.dom) {//vdom={type:'h1'}
        return vdom.dom;
    } else {
        let renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom;
        return findDOM(renderVdom);
    }
}
function unMountVdom(vdom) {
    let { type, props, ref } = vdom;
    let currentDOM = findDOM(vdom);//获取此虚拟DOM对应的真实DOM
    //vdom可能是原生组件span 类组件 classComponent 也可能是函数组件Function
    if (vdom.classInstance &amp;&amp; vdom.classInstance.componentWillUnmount) {
        vdom.classInstance.componentWillUnmount();
    }
    if (ref) {
        ref.current = null;
    }
    //如果此虚拟DOM有子节点的话，递归全部删除
    if (props.children) {
        //得到儿子的数组
        let children = Array.isArray(props.children) ? props.children : [props.children];
        children.forEach(unMountVdom);
    }
    //把自己这个虚拟DOM对应的真实DOM从界面删除
    if (currentDOM) currentDOM.parentNode.removeChild(currentDOM);
}
export function compareTwoVdom(parentDOM, oldVdom, newVdom, nextDOM) {
  if (!oldVdom &amp;&amp; !newVdom) {
    //老和新都是没有
    return;
  } else if (!!oldVdom &amp;&amp; !newVdom) {
    //老有新没有
    unMountVdom(oldVdom);
  } else if (!oldVdom &amp;&amp; !!newVdom) {
    //老没有新的有
    let newDOM = createDOM(newVdom);
    if (nextDOM) parentDOM.insertBefore(newDOM, nextDOM);
    else parentDOM.appendChild(newDOM);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
    return;
  } else if (!!oldVdom &amp;&amp; !!newVdom &amp;&amp; oldVdom.type !== newVdom.type) {
    //新老都有，但类型不同
    let newDOM = createDOM(newVdom);
    unMountVdom(oldVdom);
    if (newDOM.componentDidMount) newDOM.componentDidMount();
  } else {
    updateElement(oldVdom, newVdom);
  }
}
function updateElement(oldVdom, newVdom) {
  if (oldVdom.type &amp;&amp; oldVdom.type.$$typeof <span class="hljs-comment">=== REACT_MEMO) {</span>
    updateMemoComponent(oldVdom, newVdom);
  } else if (oldVdom.type.$$typeof <span class="hljs-comment">=== REACT_CONTEXT) {</span>
    updateContextComponent(oldVdom, newVdom);
  } else if (oldVdom.type.$$typeof <span class="hljs-comment">=== REACT_PROVIDER) {</span>
    updateProviderComponent(oldVdom, newVdom);
  } else if (oldVdom.type <span class="hljs-comment">=== REACT_TEXT &amp;&amp; newVdom.type === REACT_TEXT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    if (oldVdom.props.content !== newVdom.props.content) {
      currentDOM.textContent = newVdom.props.content;
    }
    return;
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'string') {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateProps(currentDOM, oldVdom.props, newVdom.props);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  } else if (oldVdom.type <span class="hljs-comment">=== REACT_FRAGMENT) {</span>
    let currentDOM = newVdom.dom = findDOM(oldVdom);
    updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children);
  } else if (typeof oldVdom.type <span class="hljs-comment">=== 'function') {</span>
    if (oldVdom.type.isReactComponent) {
      newVdom.classInstance = oldVdom.classInstance;
      updateClassComponent(oldVdom, newVdom);
    } else {
       updateFunctionComponent(oldVdom, newVdom);
    }
  }
}
function updateMemoComponent(oldVdom, newVdom) {
 let {type,prevProps} = oldVdom;
 let renderVdom=oldVdom.oldRenderVdom;
 if(!type.compare(prevProps,newVdom.props)){
     let currentDOM = findDOM(oldVdom);
     let parentDOM = currentDOM.parentNode;
     let {type,props} = newVdom;
     renderVdom = type.type(props);
     compareTwoVdom(parentDOM,oldVdom.oldRenderVdom,renderVdom);
 }
 newVdom.prevProps = newVdom.props;
 newVdom.oldRenderVdom = renderVdom;
}
function updateProviderComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let context = type._context;
  context._currentValue = props.value;
  let renderVdom = props.children;
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);
  newVdom.oldRenderVdom = renderVdom;
}
function updateContextComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let context = type._context;
  let renderVdom = props.children(context._currentValue);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom);
  newVdom.oldRenderVdom = renderVdom;
}
function updateFunctionComponent(oldVdom, newVdom) {
  let parentDOM = findDOM(oldVdom).parentNode;
  let { type, props } = newVdom;
  let newRenderVdom = type(props);
  compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom);
  newVdom.oldRenderVdom = newRenderVdom;
}
function updateClassComponent(oldVdom, newVdom) {
  let classInstance = newVdom.classInstance = oldVdom.classInstance;
  if (classInstance.componentWillReceiveProps) {
    classInstance.componentWillReceiveProps();
  }
  classInstance.updater.emitUpdate(newVdom.props);
}
function updateChildren(parentDOM, oldVChildren, newVChildren) {
  oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : oldVChildren ? [oldVChildren] : [];
  newVChildren = Array.isArray(newVChildren) ? newVChildren : newVChildren ? [newVChildren] : [];
  let keyedOldMap = {};
  let lastPlacedIndex = 0;
  oldVChildren.forEach((oldVChild, index) =&gt; {
    let oldKey = oldVChild.key ? oldVChild.key : index;
    keyedOldMap[oldKey] = oldVChild;
  });
  let patch = [];
  newVChildren.forEach((newVChild, index) =&gt; {
    newVChild.mountIndex = index;
    let newKey = newVChild.key ? newVChild.key : index;
    let oldVChild = keyedOldMap[newKey];
    if (oldVChild) {
      updateElement(oldVChild, newVChild);
      if (oldVChild.mountIndex &lt; lastPlacedIndex) {
        patch.push({
          type: MOVE,
          oldVChild,
          newVChild,
          mount<span class="hljs-comment">Index: index</span>
        });
      }
      delete keyedOldMap[newKey];
      lastPlacedIndex = Math.max(lastPlacedIndex, oldVChild.mountIndex);
    } else {
      patch.push({
        type: PLACEMENT,
        newVChild,
        mount<span class="hljs-comment">Index: index</span>
      });
    }
  });
  let moveVChild = patch.filter(action =&gt; action.type <span class="hljs-comment">=== MOVE).map(action =&gt; action.oldVChild);</span>
  Object.values(keyedOldMap).concat(moveVChild).forEach((oldVChild) =&gt; {
    let currentDOM = findDOM(oldVChild);
    parentDOM.removeChild(currentDOM);
  });
  patch.forEach(action =&gt; {
    let { type, oldVChild, newVChild, mountIndex } = action;
    let childNodes = parentDOM.childNodes;
    if (type <span class="hljs-comment">=== PLACEMENT) {</span>
      let newDOM = createDOM(newVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(newDOM, childNode);
      } else {
        parentDOM.appendChild(newDOM);
      }
    } else if (type <span class="hljs-comment">=== MOVE) {</span>
      let oldDOM = findDOM(oldVChild);
      let childNode = childNodes[mountIndex];
      if (childNode) {
        parentDOM.insertBefore(oldDOM, childNode);
      } else {
        parentDOM.appendChild(oldDOM);
      }
    }
  });
}
function reconcileChildren(childrenVdom, parentDOM) {
  for (let i = 0; i &lt; childrenVdom.length; i++) {
    let childVdom = childrenVdom[i];
    childVdom.mountIndex = i;
    mount(childVdom, parentDOM);
  }
}
const ReactDOM = {
  render,
  createPortal:render
};
export default ReactDOM;

</code></pre>
<p><a href="git@gitee.com:zhufengpeixun/zhufengreact.git">zhufengreact</a></p>

    